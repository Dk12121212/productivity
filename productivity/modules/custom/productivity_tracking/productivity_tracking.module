<?php
/**
 * @file
 * Code for the Productivity tracking feature.
 */

include_once 'productivity_tracking.features.inc';


/**
 * Implements hook_menu().
 */
function productivity_tracking_menu() {
  $items['node/%node/issues-tracking'] = array(
    'title' => t('Burn Report'),
    'page callback' => 'productivity_tracking_burn_report_callback',
    'page arguments' => array(1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file path' => drupal_get_path('module', 'productivity_tracking'),
    'file' => 'reports/productivity_tracking.burn.report.inc',
  );

  return $items;
}


/**
 * Implements hook_menu().
 */
function productivity_tracking_init() {
  // Set composer dir.
  global $conf;
  $conf['composer_manager_vendor_dir'] = 'profiles/productivity/composer/vendor';
  $conf['composer_manager_file_dir'] = 'profiles/productivity/composer';
}

/**
 * Get entity reference connections.
 *
 * @param $project_nid
 *  The project nid.
 *
 * @param $work_type
 *  qa, dev, management or other type.
 *
 * @return
 *   SelectQuery::execute();
 */
function productivity_tracking_get_tracking($project_nid = FALSE, $work_type = FALSE) {

  // List of issues for a project nid.
  $query = db_select('node', 'n');

  $node_fields = [
    'p' => 'field_project',
    'e' => 'field_time_estimate',
    'i' => 'field_issue_id',
    'gpi' => 'field_github_project_id',
    't' => 'field_track_log',
    'st' => 'field_issue_status',
  ];

  foreach ($node_fields as $alias => $field) {
    $query
      ->leftjoin("field_data_$field", $alias, "n.nid = $alias.entity_id");
  }

  $query
    ->leftjoin("taxonomy_term_data", 'issue_status', 'issue_status.tid = st.field_issue_status_target_id');

  $query
    ->leftjoin("taxonomy_term_data", 'pr_status', 'pr_status.tid = t.field_track_log_field_issue_status_target_id');

  $query
    ->fields('n', array('title', 'nid', 'uid'))
    ->fields('e', array('field_time_estimate_value'))
    ->fields('i', array('field_issue_id_value'))
    ->fields('gpi', array('field_github_project_id_value'))
    ->fields('t')
    ->fields('issue_status', array('name'))
    ->fields('pr_status', array('name'))
    ->fields('p', array('field_project_target_id'));

  if ($project_nid) {
    $query
      ->condition('p.field_project_target_id', $project_nid);
  }

  $query
    ->condition('type', 'tracking')
    ->condition('status', NODE_PUBLISHED)
    ->orderBy('gpi.field_github_project_id_value')
    ->orderBy('i.field_issue_id_value');

  if ($work_type) {
    $query->condition('t.field_issue_type_value', $work_type);
  }

  $result = $query->execute();

  return $result;
}


/**
 * Return estimate from github API.
 */
function productivity_tracking_get_issue_info($repo, $issue_id, $user = 'Gizra', $level = 0) {
  $cid = "$user/$repo/$issue_id-$level";
  $data = &drupal_static($cid);

  if (!isset($data)) {
    if ($cache = cache_get($cid)) {
      $data = $cache->data;
    }
    else {
      $client = github_api_client();
      try {
        // Get ifo from GH.
        $issue = $client->issue()->show($user, $repo, $issue_id);

        // Get time estimate from title, if it has any.
        $matches = array();
        $estimate = 0;
        if (preg_match('/\[([0-9]+)[h|H]\]|\[([0-9]+\.[0-9]+)[h|H]\]/', $issue['title'], $matches)) {
          // The iss has a time estimate.
          $estimate = empty($matches[1]) ? (empty($matches[2]) ? 0 : $matches[2]) : $matches[1];
        }

        // Find issue connected.
        if ($level == 0) {
          $re = '/#(\d+)/';
          $str = $issue['body'];
          preg_match_all($re, $str, $matches);
          $issues = [];
          foreach ($matches[1] as $issue_id_from_body) {
            // Collect related issues info.
            $issues[] = productivity_tracking_get_issue_info($repo, $issue_id_from_body, $user, 1);
          }
        }
        $data = [
          'issue' => $issue,
          'estimate' => $estimate,
          'related_issues' => $issues,
        ];

        cache_set($cid, $data);

      } catch (Exception $exception) {
        watchdog('productivity_github', 'looking for @cid : @exception', array('@cid' => $cid, '@exception' => $exception->getMessage()), WATCHDOG_ERROR);
        // CAche nit found.
        if ($exception->getCode() == 404){
          $data = [
            'issue' => [],
            'estimate' => 0,
            'related_issues' => [],
          ];
          cache_set($cid, $data);
        }
        return [];
      }
    }
  }
  return $data;
}

/**
 * Create a well formated log track multifileld.
 */
function productivity_tracking_create_multifields_track($track, $total_time_spent) {
  $old_track_nid = $track['entity_id'];
  $old_track_node_wrapper = entity_metadata_wrapper('node', $old_track_nid);
  $pr_nid = $track['field_issues_logs_field_github_issue_target_id'];
  $pr_wrapper = entity_metadata_wrapper('node', $pr_nid);

  // Get last push
  $last_date = 0;
  $pr_node = $pr_wrapper->value();

  if ($pr_node && $pr_node->field_push_date['und']) {
    foreach ($pr_node->field_push_date['und'] as $date) {
      $last_date = $date['value'];
    }
  }

  $log = array();
  $old_track_node = $old_track_node_wrapper->value();
  $log['field_date']['und'][0]['value'] = $old_track_node->field_work_date['und'][0]['value'];
  $log['field_issue_label']['und'][0]['value'] = $track['field_issues_logs_field_issue_label_value'];
  // PR id.
  if ($pr_node) {
    $log['field_issue_id']['und'][0]['value'] = $pr_wrapper->field_issue_id->value();
    if ($last_date) {
      $log['field_last_push']['und'][0]['value'] = $last_date;
    }
  }
  $log['field_github_username']['und'][0]['value'] = $old_track_node_wrapper->field_employee->field_github_username->value();
  $log['field_time_spent']['und'][0]['value'] = $total_time_spent;
  $log['field_issue_type']['und'][0]['value'] = $track['field_issues_logs_field_issue_type_value'];
  $log['field_employee']['und'][0]['target_id'] = $old_track_node_wrapper->field_employee->getIdentifier();

  return $log;
}

/**
 * Try to find a matching tacking node, or create one.
 *
 * @param $data
 *   array();
 *
 *  'issue_id - not requires for new
 *  'repo' - not requires for new
 *  'title'- Required for new if no issue id.
 *  'project' - Required for new
 *  'estimate' -  Required for new
 *  'uid' -  Required for new
 */
function productivity_tracking_get_tracking_node($data) {

  $node = FALSE;
  if ($data['issue_id'] && $data['repo']) {
    // Look for a tracking of the same issue.
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'tracking')
      ->fieldCondition('field_issue_id', 'value', $data['issue_id'])
      ->fieldCondition('field_github_project_id', 'value', $data['repo'])
      ->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT')
      ->range(0, 1)
      ->execute();

    if (!empty($result['node'])) {
      $nid = reset($result['node']);
      $node = node_load($nid->nid);
      $wrapper = entity_metadata_wrapper('node', $node);
    }
  }
  // Not found, create a new one.
  if ($node) {
    // If stub issue or not found before create a new node.
    if ($data['repo'] != '') {
      $title = "Tracking for issue {$data['issue_id']}/{$data['repo']}";
    }
    else {
      $title = "Tracking for project: {$data['title']}";
    }
    $values = array(
      'title' => $title,
      'type' => 'tracking',
      'uid' => $data['uid'],
      'status' => 1,
    );
    print("Creating new $title \n");
    $node = entity_create('node', $values);

    $wrapper = entity_metadata_wrapper('node', $node);
    $wrapper->field_project->set($data['project']);
    $wrapper->field_time_estimate->set($data['estimate']);
    $wrapper->field_issue_id->set($data['issue_id']);
    $wrapper->field_github_project_id->set($data['repo']);
  }

  return $wrapper;
}

/**
 * Get or create status term
 */
function productivity_tracking_get_term_status($name) {
  $vocab = taxonomy_vocabulary_machine_name_load('issue_status');
  $term = taxonomy_get_term_by_name($name);

  if (!$term) {
    $term = new stdClass();
    $term->name = $name;
    $term->vid = $vocab->vid;
    taxonomy_term_save($term);
  }
  else {
    $term = reset($term);
  }

  return $term;
}