<?php
/**
 * @file
 * Code for the Productivity tracking feature.
 */

include_once 'productivity_tracking.features.inc';

/**
 * Implements hook_menu().
 */
function productivity_tracking_menu() {
  $items['payload'] = array(
    'page callback' => 'productivity_tracking_payload',
    'access callback' => TRUE,
  );

  $items['node/%node/issues-tracking'] = array(
    'title' => t('Tracking Report'),
    'page callback' => 'productivity_tracking_burn_report_callback',
    'page arguments' => array(1, 3, 4, 5),
    // TODO: ADD access callback that checks node type == project.
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'weight' => -10,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file path' => drupal_get_path('module', 'productivity_tracking'),
    'file' => 'reports/productivity_tracking.burn.report.inc',
  );


  $items['tracking/save-tracking'] = array(
    'title' => t('Tracking Report Save Service'),
    'page callback' => 'productivity_tracking_save_callback',
    'access arguments' => array('create tracking content'),
  );

  $items['monthly-report'] = array(
    'title' => 'Issue tracking table new',
    'access arguments' => array('access content'),
    'page callback' => 'productivity_time_tracking_issue_table_callback',
    'type' => MENU_CALLBACK,
    'file' => 'monthly_report/productivity_time_tracking.table.inc'
  );


  $items['node/%node/monthly-report'] = array(
    'title' => t('Billing report'),
    'page callback' => 'productivity_time_tracking_issue_table_callback',
    'page arguments' => array(1, 3, 4, 5),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'weight' => -10,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'monthly_report/productivity_time_tracking.table.inc'
  );

  $items['per-issue/%/%/%'] = array(
    'page callback' => 'productivity_tracking_per_issue_summary',
    'page arguments' => [1, 2 ,3],
    'access arguments' => ['access content'],
  );

  return $items;
}

/**
 * Page callback; Issue summary that will be used as IFrame inside GitHub.
 *
 * @param string $gh_account_name
 *   The GitHub account name, for example "foo" in "foo/bar".
 * @param string $gh_repo_name
 *   The GitHub project name, for example "bar" in "foo/bar".
 * @param int $issue_id
 *   The issue number.
 *
 * @return array
 *   The theme of the page
 */
function productivity_tracking_per_issue_summary($gh_account_name, $gh_repo_name, $issue_id) {
  $tracking = productivity_tracking_get_tracking_nodes_per_issue("$gh_account_name/$gh_repo_name", $issue_id);
  // If there are no tracking, display a message.
  if ($tracking->rowCount() == 0) {
    // Issue is not tracked.
    return "no tracking for this issue.";
  }

  $total_row = [
    'class' => 'success',
    'data' => [
      'PR' => 'Summary',
      'date' => '',
      'estimate' => 0,
      'actual' => 0,
      'developer' => '',
      'type' => '',
      'overtime' => 'TOTAL',
    ]
  ];

  // Header.
  $table = [
    'header' => [
      t('PR'),
      t('Date'),
      t('Time estimate'),
      t('Actual time'),
      t('Developer'),
      t('type'),
      t('Overtime'),
    ],
    'attributes' => ['class' => ['per-issue-table']],
  ];

  $totals = [];

  // Prepare table for tracking data.
  while($track_record = $tracking->fetchAssoc()) {
    // Pr data.
    $pr_time = $track_record['field_track_log_field_time_spent_value'];
    if ($pr_time == '0' || $pr_time == NULL) {
      continue;
    }
    $pr_work_type = $track_record['field_track_log_field_issue_type_value'];
    $pr_developer = $track_record['field_track_log_field_github_username_value'];
    $pr_date = $track_record['field_track_log_field_date_value'];
    $track_id = $track_record['field_track_log_id'];

    // Issue data.
    $estimate = $track_record['field_time_estimate_value'];
    $nid = $track_record['nid'];

    // First row of issue.
    if (!isset($totals[$nid])) {
      // Init first total value.
      $totals[$nid] = (double)$pr_time;
      // Sum estimate.
      $total_row['data']['estimate'] += $estimate;
    }
    else {
      // Add up total work time.
      $totals[$nid] += (double) $pr_time;
      // Update actual.
      $table['rows']["nid_" . $nid]['main']['data']['actual'] = $totals[$nid];
    }
    // Update sum row.
    $total_row['data']['actual'] += $pr_time;
    $total_overtime = $total_row['data']['actual'] - $total_row['data']['estimate'];
    $total_row['data']['overtime'] = [
      'class' => ($total_overtime > 0 ? 'cell-bad-odd' : 'cell-ok-even'),
      'data' => $total_overtime,
    ];

    // Add sub rows for each PR.
    $pr_row = [
      'class' => 'warning',
      'data' => [
        'pr' => $track_record['field_track_log_field_issue_id_value'],
        'date' => date("d-m-Y", strtotime($pr_date)),
        'estimate' => '',
        'actual' => $pr_time,
        'developer' => $pr_developer,
        'type' => $pr_work_type,
        'overtime' => '',
      ],
    ];
    // Add to the table
    $table['rows']["nid_" . $nid]['tracks'][$track_id] = $pr_row;

    // Set latest date for sorting.
    if (!isset($table['rows']["nid_" . $nid]['latest']) || $table['rows']["nid_" . $nid]['latest'] < strtotime($pr_date)) {
      $table['rows']["nid_" . $nid]['latest'] = strtotime($pr_date);
    }
  }
  $sorted_rows = [];
  foreach ($table['rows'] as $row) {
    $i = 0;
    foreach ($row['tracks'] as $row_pr) {
      $i++;
      $sorted_rows[$row['latest'] . "-$i"] = $row_pr;
    }
  }

  krsort($sorted_rows);
  $table['rows'] = $sorted_rows;

  // Add total row to top of the table.
  array_unshift($table['rows'], $total_row);
  return theme('table', $table + ['sticky' => FALSE]);
}

/**
 * Get default query strings.
 */
function productivity_tracking_get_query_strings($args) {
  // Get query strings.
  $month = isset($_GET['month']) ? $_GET['month'] : date('m', time());
  $year = isset($_GET['year']) ? $_GET['year'] : date('Y', time());

  $day = isset($_GET['day']) ? $_GET['day'] : date('d', time());
  $date = "$day.$month.$year";

  // Before 14:00, display previous day as default.
  if (!isset($_GET['day']) && date('H') < '14') {
    $day = date('d', strtotime($date . "-1 days"));
    $month = date('m', strtotime($date . "-1 days"));
    $year = date('Y', strtotime($date . "-1 days"));
    $date = "$day.$month.$year";
  }

  $uid = isset($_GET['uid']) ? $_GET['uid'] : (isset($args[0]) ? $args[0] : FALSE);

  return [
  'day' => $day,
  'month' => $month,
  'year' => $year,
  'uid' => $uid,
  'date' => $date,
  'today' => ($day == date('d')),
  ];
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function productivity_tracking_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Implements hook_theme().
 */
function productivity_tracking_theme($existing, $type, $theme, $path) {
  return array(
    'productivity_time_tracking_monthly_report' => array(
      'variables' => array(
        'project_title' => NULL,
        'table' => NULL,
        'table_titles' => NULL,
      ),
      'path' => drupal_get_path('module', 'productivity_tracking') . '/monthly_report',
      'template' => 'monthly_report',
    ),
    'productivity_time_tracking_monthly_report_table' => array(
      'variables' => array(
        'project_title' => NULL,
        'table' => NULL,
        'table_titles' => NULL,
      ),
      'path' => drupal_get_path('module', 'productivity_tracking') . '/monthly_report',
      'template' => 'monthly_report_table',
    ),
    'productivity_time_tracking_project_report' => array(
      'variables' => array(),
      'path' => drupal_get_path('module', 'productivity_tracking') . '/project_report',
      'template' => 'project_report',
    ),
    'tracking_burn_table' => array(
      'variables' => array(),
      'template' => 'productivity_tracking_burn_table',
      'path' => $path . '/reports',
    ),
  );
}

/**
 *  Update tracking multifiled.
 */
function productivity_tracking_update($track, $uid) {
  // Save in regular data.
  $res = db_update('field_data_field_track_log')
    ->fields(array(
        'field_track_log_field_issue_id_value' => $track['pr'] ? $track['pr'] : NULL,
        'field_track_log_field_issue_label_value' => $track['description'],
        'field_track_log_field_issue_type_value' => $track['type'],
        'field_track_log_field_time_spent_value' => $track['time_spent'] ? $track['time_spent'] : 0,
      )
    )
    ->condition('field_track_log_id', $track['mlid'])
    ->condition('field_track_log_field_employee_target_id', $uid)
    ->execute();

  // Save in revision.
  $res_rev = db_update('field_revision_field_track_log')
    ->fields(array(
        'field_track_log_field_issue_id_value' => $track['pr'] ? $track['pr'] : NULL,
        'field_track_log_field_issue_label_value' => $track['description'],
        'field_track_log_field_issue_type_value' => $track['type'],
        'field_track_log_field_time_spent_value' => $track['time_spent'] ? $track['time_spent'] : 0,
      )
    )
    ->condition('field_track_log_id', $track['mlid'])
    ->condition('field_track_log_field_employee_target_id', $uid)
    ->execute();

  return $res && $res_rev;
}

/**
 *  Delete tracking multifiled.
 */
function productivity_tracking_delete($mlid, $uid) {
  $res = db_delete('field_data_field_track_log')
    ->condition('field_track_log_id', $mlid)
    ->condition('field_track_log_field_employee_target_id', $uid)
    ->execute();

  $res_rev = db_delete('field_revision_field_track_log')
    ->condition('field_track_log_id', $mlid)
    ->condition('field_track_log_field_employee_target_id', $uid)
    ->execute();

  return $res && $res_rev;
}

/**
 * Save tracking from tacking table.
 */
function productivity_tracking_save_callback() {
  $results = [];
  $json = file_get_contents('php://input');
  $tracking = json_decode($json, TRUE);
  $uid = $tracking['data']['uid'];
  foreach ($tracking['tracking'] as $track) {
    // Existing Tracking, just update.
    $ids = explode('|', $track['mlid']);
    $attr = $ids[1];
    $delete = $ids[2];
    $track['mlid'] = $ids[0];

    // Delete.
    if ($delete) {
      // Make sure delete is not on a new item that was never saved.
      if ($track['mlid'] != 'new') {
        $results[] = array(
          'mlid' => $track['mlid'],
          'new' => 0,
          'delete' => $delete,
          'attr' => $attr,
          'result' => productivity_tracking_delete($track['mlid'], $uid),
        );
      }
    }
    // Update.
    elseif ($track['mlid'] != 'new') {
      // Update info that might change.
      $results[] = array(
        'mlid' => $track['mlid'],
        'new' => 0,
        'delete' => $delete,
        'attr' => $attr,
        'result' => productivity_tracking_update($track, $uid),
      );
    }
    // New tracking.
    else {

      // Same structure as GH API.
      $issue = array(
        'number' => $track['issue'] ? $track['issue'] : 0,
        'title' => $track['description'],
        'status' => 'open',
        'labels' => [],
        'milestone' => [],
      );
      // TODO: Get more info from GH when possible.
      $data_issue = [
        'time' => $track['time_spent'],
        'type' => $track['type'],
        'repo' => $track['repo'],
        'estimate' => 0,
        'issue' => $issue,
        'project' => $track['project_nid'],
        'uid' => $uid,
      ];

      // Get or create tracking node.
      $wrapper = productivity_tracking_get_tracking_node($data_issue, FALSE, FALSE, FALSE);
      // Save PR.
      $node = $wrapper->value();
      $logs = array();
      $account_wrapper = entity_metadata_wrapper('user', $uid);

      $data = [
        'date_start' => date("Y-m-d H:i:s", strtotime($tracking['data']['date_str'])),
        'date_end' => date("Y-m-d H:i:s", strtotime($tracking['data']['date_str'])),
        'label' => $track['description'],
        'pr_id' => $track['pr'] ? $track['pr'] : 0,
        'status' => 'open',
        'github_username' => $account_wrapper->field_github_username->value(),
        'time_spent' => $track['time_spent'],
        'issue_type' => $track['type'],
        'uid' => $uid,
      ];

      // Create a new tracking data.
      $logs['und'][] = productivity_tracking_create_multifields_track($data, $wrapper);

      // Rebuild structure with previous logs.
      $index = 0;
      if (isset($node->field_track_log['und'])) {
        foreach ($node->field_track_log['und'] as $existing_log) {
          $logs['und'][] = $existing_log;
          $index++;
        }
      }
      $node->field_track_log = $logs;
      // Save node.
      $wrapper->save();
      $results[] = array(
        'mlid' => $node->field_track_log['und'][$index]['id'],
        'result' => 1,
        'delete' => $delete,
        'attr' => $attr,
        'new' => 1,
      );
    }
  }
  global $user;
  ctools_include('content');
  $nav = ctools_content_render('tracking_nav', 'tracking_nav', [], [], [$user->uid], [], '');
  $nav = $nav->content;
  drupal_json_output(array(
    'saved' => $results,
    'nav' => $nav,
    )
  );
  drupal_exit();
}

/**
 * Github endpoint callback
 */
function productivity_tracking_payload() {
  // set NULL to disable check
  $hookSecret = variable_get('productivity_github_secret', '1234');

  $rawPost = NULL;
  // Check security secret.
  if ($hookSecret !== NULL) {
    if (!isset($_SERVER['HTTP_X_HUB_SIGNATURE'])) {
      throw new \Exception("HTTP header 'X-Hub-Signature' is missing.");
    }
    elseif (!extension_loaded('hash')) {
      throw new \Exception("Missing 'hash' extension to check the secret code validity.");
    }

    // Separate algo and hash.
    list($algo, $hash) = explode('=', $_SERVER['HTTP_X_HUB_SIGNATURE'], 2) + array('', '');
    if (!in_array($algo, hash_algos(), TRUE)) {
      throw new \Exception("Hash algorithm '$algo' is not supported.");
    }

    // Check hash.
    $rawPost = file_get_contents('php://input');
    if ($hash !== hash_hmac($algo, $rawPost, $hookSecret)) {
      throw new \Exception('Hook secret does not match.');
    }
  };

  // Check event header.
  if (!isset($_SERVER['CONTENT_TYPE'])) {
    throw new \Exception("Missing HTTP 'Content-Type' header.");
  }
  elseif (!isset($_SERVER['HTTP_X_GITHUB_EVENT'])) {
    throw new \Exception("Missing HTTP 'X-Github-Event' header.");
  }


  switch ($_SERVER['CONTENT_TYPE']) {
    case 'application/json':
      $json = $rawPost ?: file_get_contents('php://input');
      break;
    case 'application/x-www-form-urlencoded':
      $json = $_POST['payload'];
      break;
    default:
      throw new \Exception("Unsupported content type: $_SERVER[HTTP_CONTENT_TYPE]");
  }

  # Payload structure depends on triggered event
  # https://developer.github.com/v3/activity/events/types/
  $payload = json_decode($json, TRUE);

  switch ($event = strtolower($_SERVER['HTTP_X_GITHUB_EVENT'])) {
    // Issue event https://developer.github.com/v3/activity/events/types/#issuesevent
    // https://developer.github.com/v3/activity/events/types/#pullrequestevent.
    case 'issues' || 'pull_request':
      productivity_tracking_gh_payload($payload, $event);
      break;
    default:
      header('HTTP/1.0 404 Not Found');
      echo "Event:{$_SERVER['HTTP_X_GITHUB_EVENT']} Payload:\n";
      watchdog('productivity_tracking', t('@event is not supported', array('@event' => $_SERVER['HTTP_X_GITHUB_EVENT'])));
      die();
  }
}

/**
 * Handle PR event.
 */
function productivity_tracking_gh_payload($payload, $event) {
  // Get related issue from PR body.
  if ($event == 'pull_request') {
    $pr = $payload['pull_request'];
    $pr['github_username'] = $payload['repository']['name'];
    // Look in body for issue.
    $issues = productivity_tracking_parse_related_issue($payload['pull_request']['body'], $payload['repository']['name'], $payload['repository']['owner']['login']);
    // Look in title for issue.
    $issues += productivity_tracking_parse_related_issue($payload['pull_request']['title'], $payload['repository']['name'], $payload['repository']['owner']['login']);

  }
  // Issue event.
  elseif ($event == 'issues') {
    // Take issue info straight from payload.
    $pr = FALSE;
    $issues[] = [
      'issue' => $payload['issue'],
      'estimate' => productivity_tracking_parse_time_estimate($payload['issue']['title']),
      'related_issues' => [],
    ];
  }
  // Unsupported event.
  else {
    throw new \Exception("Unsupported event type: $event");
  }

  // No issue connected.
  if (empty($issues)) {
    // If PR is orphan and Pr has an estimate in title, then create a tracking.
    if ($estimate = productivity_tracking_parse_time_estimate($payload['pull_request']['title'])) {
      $issues[] = [
        'issue' => $payload['pull_request'],
        'estimate' => $estimate,
        'related_issues' => [],
      ];
    }
    else {
      // TODO: Send message to account manager about no issue and no estimate.
      // TODO: Probably better to have this in single daily email.
      $issues[] = [
        'issue' => $payload['pull_request'],
        'estimate' => 0,
        'related_issues' => [],
      ];
    }
  }

  // Go over all related issue and get related tracking node.
  foreach ($issues as $issue) {
    // Save stub or existing issue.
    if (!$uid = productivity_tracking_get_uid_by_github_username($payload['sender']['login'])) {
      // Bypass unknown user.
      continue;
    }
    productivity_tracking_save_tracking($issue, $pr, $uid, $payload['sender']['login'], $payload['repository']);
  }

}

/**
 * Save issue data and pr in tracking node.
 *
 * @param $issue
 *  the issue to save
 * @param $pr
 *   The pr related or FALSe if no PR
 * @param $gh_username
 * @param $repo
 *   Repo array
 * @return bool
 */
function productivity_tracking_save_tracking($issue, $pr, $uid, $github_username, $repo, $dont_create = FALSE, $check_race_condition = TRUE) {
  $project_nid = productivity_tracking_get_project_by_repository($repo);

  // Bypass if project or user are not in the system.
  if (!$project_nid) {
    return FALSE;
  }

  $data_issue = [
    'repo' => $repo['full_name'],
    'estimate' => $issue['estimate'],
    'issue' => $issue['issue'],
    'project' => $project_nid,
    'uid' => $uid,
  ];

  if(!$wrapper = productivity_tracking_get_tracking_node($data_issue, TRUE, $dont_create, $check_race_condition)) {
    // Case of race condition, or issue not found with just_update = true.
    return FALSE;
  }

  // Only create tracking stub if a new PR was pushed.
  // This will be later used to prepopulate the tracking for developers.
  if ($pr) {
    $node = $wrapper->value();
    $logs = array();

    // We should create one stub log per day per user per issue number.
    // issue_id.
    $found_key = -1;
    if (isset($node->field_track_log['und'])) {
      foreach ($node->field_track_log['und'] as $key => $existing_log) {
        // Convert date.
        $existing_pr_day = date('Ymd', strtotime($existing_log['field_date']['und'][0]['value']));
        $pr_payload_date = date('Ymd', strtotime($pr['updated_at']));

        // Check if we have a match for same PR, same day, Same user.
        if ($existing_log['field_github_username']['und'][0]['value'] == $github_username
          && $existing_log['field_issue_id']['und'][0]['value'] == $pr['number']
          && $existing_pr_day == $pr_payload_date) {
          $found_key = $key;
          break;
        }
      }
    }
    // Update existing log, with new info.
    if ($found_key != -1) {
      // Update info that might change.
      $node->field_track_log['und'][$found_key]['field_issue_label']['und'][0]['value'] = $pr['title'];
      $node->field_track_log['und'][$found_key]['field_date']['und'][0]['value2'] = date("Y-m-d H:i:s",strtotime($pr['updated_at']));

      $term = productivity_tracking_get_term($pr['state']);
      $node->field_track_log['und'][$found_key]['field_issue_status']['und'][0]['target_id'] = $term->tid;
    }
    else {
      $data = [
        'date_start' => date("Y-m-d H:i:s",strtotime($pr['updated_at'])),
        'date_end' => date("Y-m-d H:i:s",strtotime($pr['updated_at'])),
        'label' => $pr['title'],
        'pr_id' => $pr['number'],
        'status' => $pr['state'],
        'github_username' => $github_username,
        'time_spent' => 0,
        'issue_type' => '',
        'uid' => $uid,
      ];
      // Create a new tracking data.
      $logs['und'][] = productivity_tracking_create_multifields_track($data, $wrapper);

      // Rebuild structure with previous logs.
      if (isset($node->field_track_log['und'])) {
        foreach ($node->field_track_log['und'] as $existing_log) {
          $logs['und'][] = $existing_log;
        }
      }
      $node->field_track_log = $logs;
    }
  }

  // Save node.
  return $wrapper->save();
}
/**
 *
 * Get the project ID from the repository name.
 *
 * @param $repository_info
 *  A github repository names.
 *
 * @return int
 *   Project node ID.
 */
function productivity_tracking_get_project_by_repository($repository_info) {
  // We need to add a second query since value2 of date has a default of value(1).
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->fieldCondition('field_github_repository_name', 'value', $repository_info['full_name'])
    // Just look for active or not started projects.
    ->fieldCondition('field_status', 'value', 'done', '!=')
    ->propertyOrderBy('created', 'DESC')
    ->propertyOrderBy('type', 'project')
    ->range(0, 1)
    ->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');

  $result = $query->execute();

  if (isset($result['node'])) {
    $nid = reset($result['node']);
    return $nid;
  }

  productivity_admin_log("No project with github repository: $repository_info", 'success');
  // Print error if no repo was found.
  watchdog('productivity', t('No project with github repository: @repository', array('@repository' => print_r($repository_info, TRUE))));
  return FALSE;
}

/**
 * Get user ID from the GitHub username.
 *
 * @param string $github_username
 *   A github username.
 *
 * @return int
 *   Account ID.
 */
function productivity_tracking_get_uid_by_github_username($github_username) {
  if ($uid = productivity_tracking_get_entity_id_by_field_value('field_github_username', 'user', $github_username)) {
    return $uid;
  }
  productivity_admin_log("No user with github username: $github_username", 'success');
  watchdog('productivity', t('No user with github username: @username', array('@username' => $github_username)));
}

/**
 * Fetch an entity ID by a unique field value.
 *
 * @param $field
 *   Field name.
 * @param $bundle
 *   Entity bundle.
 * @param $value
 *   Field value.
 *
 * @return int
 *   Entity ID.
 */
function productivity_tracking_get_entity_id_by_field_value($field, $bundle, $value) {
  // Using db_select to allow this query for anonymous.
  $result = db_select('field_data_' . $field, 'f')
    ->fields('f', array('entity_id'))
    ->condition('bundle', $bundle)
    ->condition($field . '_value', $value)
    ->range(0, 1)
    ->execute()
    ->fetchAssoc();

  if (!empty($result['entity_id'])) {
    return $result['entity_id'];
  }
}

/**
 * Get entity reference connections.
 *
 * @param $project_nid
 *  The project nid.
 *
 * @param $work_type
 *  qa, dev, management or other type.
 *
 * @return
 *   SelectQuery::execute();
 */
function productivity_tracking_get_tracking($project_nid = FALSE, $work_type = FALSE, $year = FALSE, $month = FALSE) {
  if ($month == 'all') {
    $project_start_month = format_string("@year-01-01", array('@year' => $year));
    $project_end_month = format_string("@year-12-31", array('@year' => $year));
  }
  //
  else {
    $project_start_month = format_string("@year-@month-01", array(
      '@year' => $year,
      '@month' => $month
    ));
    $project_end_month = format_string("@year-@month-01", array(
      '@year' => ($month == 12) ? $year + 1 : $year,
      '@month' => ($month == 12) ? 1 : ($month + 1),
    ));
  }

  // List of issues for a project nid.
  $query = db_select('node', 'n');

  $node_fields = [
    'p' => 'field_project',
    'e' => 'field_time_estimate',
    'i' => 'field_issue_id',
    'gpi' => 'field_github_project_id',
    't' => 'field_track_log',
    'st' => 'field_issue_status',
    'mi' => 'field_gh_milestone',
    'b' => 'body',
  ];


  foreach ($node_fields as $alias => $field) {
    $query
      ->leftjoin("field_data_$field", $alias, "n.nid = $alias.entity_id");
  }

  $query
    ->leftjoin("taxonomy_term_data", 'issue_status', 'issue_status.tid = st.field_issue_status_target_id');

  $query
    ->leftjoin("taxonomy_term_data", 'pr_status', 'pr_status.tid = t.field_track_log_field_issue_status_target_id');

  $query
    ->fields('n', array('title', 'nid', 'uid'))
    ->fields('e', array('field_time_estimate_value'))
    ->fields('i', array('field_issue_id_value'))
    ->fields('gpi', array('field_github_project_id_value'))
    ->fields('t')
    ->fields('mi')
    ->fields('b')
    ->fields('issue_status', array('name'))
    ->fields('pr_status', array('name'))
    ->fields('p', array('field_project_target_id'));

  // Add multiple labels in a single row, wigh comma separator.
  $labels = '(SELECT GROUP_CONCAT(taxo.name SEPARATOR \', \')
  FROM `field_data_field_gh_label` AS label
  LEFT JOIN `taxonomy_term_data` taxo ON label.field_gh_label_target_id = taxo.tid
  WHERE label.entity_id = n.nid)';
  $query->addExpression($labels, 'labels');

  if ($project_nid) {
    $query
      ->condition('p.field_project_target_id', $project_nid);
  }

  // Return all time.
  if ($year && $year != 'all') {
    $query
      ->condition('t.field_track_log_field_date_value', $project_start_month, '>=')
      ->condition('t.field_track_log_field_date_value', $project_end_month, '<');
  }

  $query
    ->condition('type', 'tracking')
    ->condition('status', NODE_PUBLISHED)
    ->orderBy('gpi.field_github_project_id_value')
    ->orderBy('i.field_issue_id_value');

  if ($work_type) {
    $query->condition('t.field_track_log_field_issue_type_value', $work_type);
  }

  $result = $query->execute();

  return $result;
}

/**
 * Get entity reference connections.
 *
 * @param $repo
 *  Repo id ex. Gizra/productivity
 *
 * @param $issue_id
 *  Issue number.
 *
 * @return
 *   SelectQuery::execute();
 */
function productivity_tracking_get_tracking_nodes_per_issue($repo, $issue_id) {
  // List of issues for a project nid.
  $query = db_select('node', 'n');

  $node_fields = [
    'p' => 'field_project',
    'e' => 'field_time_estimate',
    'i' => 'field_issue_id',
    'gpi' => 'field_github_project_id',
    'st' => 'field_issue_status',
    't' => 'field_track_log',
  ];

  foreach ($node_fields as $alias => $field) {
    $query
      ->leftjoin("field_data_$field", $alias, "n.nid = $alias.entity_id");
  }

  $query
    ->leftjoin("taxonomy_term_data", 'issue_status', 'issue_status.tid = st.field_issue_status_target_id');

  $query
    ->fields('n', array('title', 'nid', 'uid'))
    ->fields('e', array('field_time_estimate_value'))
    ->fields('i', array('field_issue_id_value'))
    ->fields('gpi', array('field_github_project_id_value'))
    ->fields('t')
    ->fields('issue_status', array('name'))
    ->fields('p', array('field_project_target_id'));

  $query
    ->condition('gpi.field_github_project_id_value', $repo)
    ->condition('i.field_issue_id_value', $issue_id);

  $query
    ->condition('type', 'tracking')
    ->condition('status', NODE_PUBLISHED)
    ->orderBy('gpi.field_github_project_id_value')
    ->orderBy('i.field_issue_id_value');

  $result = $query->execute();
  return $result;
}

/**
 * Get entity reference connections.
 *
 * @param $project_nid
 *  The project nid.
 *
 * @param $work_type
 *  qa, dev, management or other type.
 *
 * @return
 *   SelectQuery::execute();
 */
function productivity_tracking_get_tracking_nodes($project_nid = FALSE) {
  // List of issues for a project nid.
  $query = db_select('node', 'n');

  $node_fields = [
    'p' => 'field_project',
    'e' => 'field_time_estimate',
    'i' => 'field_issue_id',
    'gpi' => 'field_github_project_id',
    'st' => 'field_issue_status',
    'b' => 'body',
  ];

  foreach ($node_fields as $alias => $field) {
    $query
      ->leftjoin("field_data_$field", $alias, "n.nid = $alias.entity_id");
  }

  $query
    ->leftjoin("taxonomy_term_data", 'issue_status', 'issue_status.tid = st.field_issue_status_target_id');


  $query
    ->fields('n', array('title', 'nid', 'uid'))
    ->fields('e', array('field_time_estimate_value'))
    ->fields('i', array('field_issue_id_value'))
    ->fields('gpi', array('field_github_project_id_value'))
    ->fields('b')
    ->fields('issue_status', array('name'))
    ->fields('p', array('field_project_target_id'));

  if ($project_nid) {
    $query
      ->condition('p.field_project_target_id', $project_nid);
  }

  $query
    ->condition('type', 'tracking')
    ->condition('status', NODE_PUBLISHED)
    ->orderBy('gpi.field_github_project_id_value')
    ->orderBy('i.field_issue_id_value');

  $result = $query->execute();

  return $result;
}

/**
 * @param $project_nid
 * @param $work_type
 * @param bool $year
 * @param string $month
 * @return \DatabaseStatementInterface
 */
function productivity_tracking_get_tracking_total_estimate($project_nid, $work_type = FALSE, $year = FALSE, $month = 'all') {
  $query =  "
  SELECT SUM(e.field_time_estimate_value) AS total_estimate
  FROM {node} n
  LEFT OUTER JOIN field_data_field_project p ON n.nid = p.entity_id
  LEFT OUTER JOIN field_data_field_time_estimate e ON n.nid = e.entity_id
  WHERE (type = 'tracking') AND (status = '1') AND (p.field_project_target_id = :pid)";

  $args[':pid'] = $project_nid;
  if ($work_type) {
    $query .= "
    AND EXISTS(
    SELECT t.field_track_log_field_issue_type_value
      FROM {field_data_field_track_log} t
      WHERE t.field_track_log_field_issue_type_value = :type AND n.nid = t.entity_id)";
    $args[':type'] = $work_type;
  }

  return db_query($query, $args)->fetchField();
}
/**
 *
 * Calculate the Total hours done.
 *
 * @param $project_nid
 * @param bool $work_type
 * @param bool $uid
 * @param bool $year
 * @param string $month
 * @return mixed
 */
function productivity_tracking_get_tracking_total($project_nid, $work_type = FALSE, $uid = FALSE, $year = FALSE, $month = 'all') {
  if ($month == 'all') {
    $start_date = format_string("@year-01-01 00:00:00", array('@year' => $year));
    $end_date = format_string("@year-01-01 00:00:00", array('@year' => $year + 1));
  }
  else {
    $start_date = format_string("@year-@month-01 00:00:00", array(
      '@year' => $year,
      '@month' => str_pad($month, 2, '0', STR_PAD_LEFT),
    ));
    $end_date = format_string("@year-@month-01 00:00:00", array(
      '@year' => ($month == 12) ? $year + 1 : $year,
      '@month' => str_pad(($month == 12) ? 1 : ($month + 1), 2, '0', STR_PAD_LEFT),
    ));
  }

  // List of issues for a project nid.
  $query = db_select('node', 'n');

  $node_fields = [
    'p' => 'field_project',
    'e' => 'field_time_estimate',
    't' => 'field_track_log',
  ];

  foreach ($node_fields as $alias => $field) {
    $query
      ->leftjoin("field_data_$field", $alias, "n.nid = $alias.entity_id");
  }

  $query
    ->condition('type', 'tracking')
    ->condition('status', NODE_PUBLISHED);

  if ($uid) {
    $query->fields('n', array('uid'));

    if ($uid == 'all') {
      $query->groupBy('n.uid');
    }
    else {
      $query->condition('t.field_track_log_field_employee_target_id', $uid);
    }
  }

  if ($project_nid) {
    $query->condition('p.field_project_target_id', $project_nid);
  }

  if ($work_type) {
    $query->condition('t.field_track_log_field_issue_type_value', $work_type);
  }

  // Return all time.
  if ($year) {
    $query
      ->condition('t.field_track_log_field_date_value', $start_date, '>=')
      ->condition('t.field_track_log_field_date_value', $end_date, '<');
  }

  $query->addExpression('SUM(t.field_track_log_field_time_spent_value)', 'total_done');

  if ($uid == 'all') {
    $total = $query->execute()->fetchAllKeyed();
  }
  else {
    $total = $query->execute()->fetchAll();
    // Calculate estimate, for the given work type.
    $total['0']->total_estimate = productivity_tracking_get_tracking_total_estimate($project_nid, $work_type, $year, $month );
  }
  return $total;
}
/**
 * Get entity reference connections.
 *
 * @param $work_type
 *  qa, dev, management or other type.
 *
 * @return
 *   SelectQuery::execute();
 */
function productivity_tracking_get_tracking_by_user($uid, $year = FALSE, $month = 'all', $work_type = FALSE, $project_nid = FALSE) {
  if ($month == 'all') {
    $start_date = format_string("@year-01-01 00:00:00", array('@year' => $year));
    $end_date = format_string("@year-01-01 00:00:00", array('@year' => $year + 1));
  }
  else {
    $start_date = format_string("@year-@month-01 00:00:00", array(
      '@year' => $year,
      '@month' => str_pad($month, 2, '0', STR_PAD_LEFT),
    ));
    $end_date = format_string("@year-@month-01 00:00:00", array(
      '@year' => ($month == 12) ? $year + 1 : $year,
      '@month' => str_pad(($month == 12) ? 1 : ($month + 1), 2, '0', STR_PAD_LEFT),
    ));
  }

  // List of issues for a project nid.
  $query = db_select('node', 'n');

  $node_fields = [
    'p' => 'field_project',
    'e' => 'field_time_estimate',
    'i' => 'field_issue_id',
    'gpi' => 'field_github_project_id',
    't' => 'field_track_log',
    'st' => 'field_issue_status',
    'b' => 'body',
  ];

  foreach ($node_fields as $alias => $field) {
    $query
      ->leftjoin("field_data_$field", $alias, "n.nid = $alias.entity_id");
  }

  $query
    ->leftjoin("node", 'node_project', 'p.field_project_target_id = node_project.nid');

  $query
    ->leftjoin("taxonomy_term_data", 'issue_status', 'issue_status.tid = st.field_issue_status_target_id');

  $query
    ->leftjoin("taxonomy_term_data", 'pr_status', 'pr_status.tid = t.field_track_log_field_issue_status_target_id');

  $query
    ->fields('n', array('title', 'nid', 'uid'))
    ->fields('node_project', array('title'))
    ->fields('e', array('field_time_estimate_value'))
    ->fields('i', array('field_issue_id_value'))
    ->fields('gpi', array('field_github_project_id_value'))
    ->fields('t')
    ->fields('b')
    ->fields('issue_status', array('name'))
    ->fields('pr_status', array('name'))
    ->fields('p', array('field_project_target_id'));

  $query
    ->condition('n.type', 'tracking')
    ->condition('n.status', NODE_PUBLISHED)
    ->orderBy('t.field_track_log_id')
    ->orderBy('gpi.field_github_project_id_value')
    ->orderBy('i.field_issue_id_value');


  if ($uid) {
    $query->condition('t.field_track_log_field_employee_target_id', $uid);
  }

  if ($project_nid) {
    $query->condition('p.field_project_target_id', $project_nid);
  }

  if ($work_type) {
    $query->condition('t.field_track_log_field_issue_type_value', $work_type);
  }

  // Return all time.
  if ($year) {
    $query
      ->condition('t.field_track_log_field_date_value', $start_date, '>=')
      ->condition('t.field_track_log_field_date_value', $end_date, '<');
  }

  $result = $query->execute();

  return $result;
}

/**
 * Parse time estimation from string.
 */
function productivity_tracking_parse_time_estimate($string) {
  // Get time estimate from title, if it has any.
  $matches = array();
  $estimate = 0;
  // Look for [12], [12H], [12h], [12.5h], [12.5H], [12.4] formats.
  if (preg_match('/\[([0-9]*\.?[0-9]*)[h|H]?\]/', $string, $matches)) {
    // The issue has a time estimate.
    $estimate = empty($matches[1]) ? (empty($matches[2]) ? 0 : $matches[2]) : $matches[1];
  }
  return $estimate;
}

/**
 * Parse related issue numnber.
 *
 * @param $no_hash
 *   Search fo issue number without # too.
 *
 * @return array().
 *   An array with GH issue array with info from GH.
 */
function productivity_tracking_parse_related_issue($string, $repo, $user) {
  $re = '/#(\d+)/';
  $str = $string;
  preg_match_all($re, $str, $matches);
  $issues = [];
  foreach ($matches[1] as $issue_id_from_body) {
    $issue = productivity_tracking_get_issue_info($repo, $issue_id_from_body, $user, FALSE);
    if (!isset($issue['issue']['pull_request'])) {
      // Only adds non PRs
      $issues[$issue_id_from_body] = $issue;
    }
  }
  return $issues;
}

/**
 * Return PR or issue info with estimate from github API.
 */
function productivity_tracking_get_issue_info($repo, $issue_id, $user = 'Gizra', $with_related = TRUE, $no_cache = FALSE) {
  // Get ifo from GH.
  $issue = productivity_tracking_get_issue($repo, $issue_id, $user, $no_cache);

  if (empty($issue)) {
    return [
      'issue' => [] ,
      'estimate' => 0,
      'related_issues' => [],
    ];
  }

  // Get time estimate from title, if it has any.
  $estimate = productivity_tracking_parse_time_estimate($issue['title']);

  $issues = [];
  // Find issue connected.
  if ($with_related) {
    $issues = productivity_tracking_parse_related_issue($issue['body'], $repo, $user);
  }

  $data = [
    'issue' => $issue,
    'estimate' => $estimate,
    'related_issues' => $issues,
  ];

  return $data;
}

/**
 * Return PR or issue info from github API.
 */
function productivity_tracking_get_issue($repo, $issue_id, $user = 'Gizra', $no_cache = FALSE) {
  $cid = "$user/$repo/$issue_id";
  $data = &drupal_static($cid);

  if (!isset($data)) {
    $cache = cache_get($cid);
    // TODO: Fixing a case the array is empty, but we get a boolean TRUE,
    // need to figure out why.
    if ($data === TRUE) {
      $data = FALSE;
    }
    if ($cache && !$no_cache) {
      $data = $cache->data;
    }
    else {
      $client = github_api_client();
      try {
        // Get ifo from GH.
        $data =  $client->issue()->show($user, $repo, $issue_id);

        cache_set($cid, $data);

      } catch (Exception $exception) {
        watchdog('productivity_github', 'looking for @cid : @exception', array('@cid' => $cid, '@exception' => $exception->getMessage()), WATCHDOG_ERROR);
        // CAche nit found.
        if ($exception->getCode() == 404){
          cache_set($cid, []);
        }
        return [];
      }
    }
  }
  return $data;
}

/**
 * Create a well formated log track multifileld.
 *
 * @param $data
 *  array().
 *
 *   'date' => time(),
 *   'label' => '',
 *   'last_push' => time(),
 *   'pr_id' => 0,
 *   'status' => 'closed',
 *   'github_username' => '',
 *   'time_spent' => 0,
 *   'issue_type' => 'dev',
 *   'uid' => 0,
 */
function productivity_tracking_create_multifields_track($data) {
  $data += [
    'date_start' => time(),
    'date_end' => time(),
    'label' => '',
    'last_push' => time(),
    'pr_id' => 0,
    'status' => 'closed',
    'github_username' => '',
    'time_spent' => 0,
    'issue_type' => '',
    'uid' => 0,
  ];

  $log = array();
  $log['field_date']['und'][0]['value'] = $data['date_start'];
  $log['field_date']['und'][0]['value2'] = $data['date_end'];
  $log['field_issue_label']['und'][0]['value'] =  $data['label'];
  // Last push use as last edited field.
  $log['field_last_push']['und'][0]['value'] = date("Y-m-d H:i:s");
  $log['field_issue_id']['und'][0]['value'] =  $data['pr_id'];
  $term = productivity_tracking_get_term($data['status']);
  $log['field_issue_status']['und'][0]['target_id'] = $term->tid;
  $log['field_github_username']['und'][0]['value'] =  $data['github_username'];
  $log['field_time_spent']['und'][0]['value'] = $data['time_spent'];
  $log['field_issue_type']['und'][0]['value'] = $data['issue_type'];
  $log['field_employee']['und'][0]['target_id'] = $data['uid'];

  return $log;
}

/**
 * Check already in process same issue.
 */
function productivity_tracking_check_race_condition($data) {
  // We need to take care of race condition, 2 request for same issue
  // might come together, and we don't want duplicates to be created.
  // The technique is to use a variable that mark processing and to wait 5 sec.
  $uuid = ctools_uuid_generate();
  $issue_id = $data['repo'] . '/' . $data['issue']['number'];
  db_insert('productivity_github_webhook_duplicates')
    ->fields(array(
      'issue_id' => $issue_id,
      'uuid' => $uuid,
    ))
    ->execute();

  sleep(5);

  $query_duplicates = db_select('productivity_github_webhook_duplicates', 'g')
    ->condition('g.issue_id', $issue_id, '=')
    ->fields('g', array('uuid'))
    ->orderBy('g.uuid')
    ->execute();

  $count = $query_duplicates->rowCount();
  $chosen_request = $query_duplicates->fetchAssoc();

  // Delete the temp db entry.
  $res = db_delete('productivity_github_webhook_duplicates')
    ->condition('uuid', $uuid)
    ->execute();

  if ($res != 1) {
    watchdog('productivity', "Unable to delete entry in productivity_github_webhook_duplicates for uuid $uuid", WATCHDOG_CRITICAL);
  }
  // We have a duplicate, if it's the first one than let go, otherwise
  // don't create.
  if ($count > 1 && $chosen_request['uuid'] != $uuid) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Try to find a matching tacking node, or create one.
 *
 * @param $data
 *   array();
 *
 *  'issue - Issue structure from GH.
 *  'repo' - not requires for new
 *  'project' - Required for new
 *  'estimate' -  Required for new
 *  'uid' -  Required for new
 */
function productivity_tracking_get_tracking_node($data, $update_existing = FALSE, $dont_create = FALSE, $check_race_condition = TRUE) {

  $wrapper = FALSE;
  if ($data['issue']['number'] && $data['repo']) {

    if ($check_race_condition) {
      if (productivity_tracking_check_race_condition($data)) {
        return FALSE;
      }
    }

    // Look for a tracking of the same issue.
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'tracking')
      ->fieldCondition('field_issue_id', 'value', $data['issue']['number'])
      ->fieldCondition('field_github_project_id', 'value', $data['repo'])
      ->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT')
      ->range(0, 1)
      ->execute();

    // Found existing, re-use.
    if (!empty($result['node'])) {
      $nid = reset($result['node']);
      $node = node_load($nid->nid);
      $wrapper = entity_metadata_wrapper('node', $node);

      // Update estimate and status.
      if ($update_existing) {
        // Pass true in 3rd param to not update project ref.
        productivity_tracking_set_tracking_data($data, $wrapper, TRUE);
      }
    }
  }
  // Don't create a new node.
  if ($dont_create) {
    return $wrapper;
  }

  // Not found, create a new one.
  if (!$wrapper) {
    // If it's a GH related tracking.
    if ($data['issue']['number'] != '') {
      $title = "Tracking for issue {$data['repo']}/{$data['issue']['number']}";
    }
    else {
      if (!$data['issue']['title']) {
        $project_wrapper = entity_metadata_wrapper('node', $data['project']);
        $data['issue']['title'] = $project_wrapper->label();
      }
      $title = "Tracking for project: {$data['title']}";
    }
    global $user;

    $values = array(
      'title' => $title,
      'type' => 'tracking',
      // If author is anonymous (pushed form GH) use employee as default.
      'uid' => $user->uid ? $data['uid'] : $user->uid,
      'status' => 1,
    );
    $node = entity_create('node', $values);

    $wrapper = entity_metadata_wrapper('node', $node);
    productivity_tracking_set_tracking_data($data, $wrapper);
  }

  return $wrapper;
}

/**
 * Set values to node tracking
 */
function productivity_tracking_set_tracking_data($data, $wrapper, $only_gh_data = FALSE) {
  // Prevent override of project when in case of multiple project per repo.
  if (!$only_gh_data) {
    $wrapper->field_project->set($data['project']);
  }
  $wrapper->field_issue_id->set($data['issue']['number']);
  $wrapper->field_github_project_id->set($data['repo']);
  $wrapper->body->value->set($data['issue']['title']);

  $wrapper->field_time_estimate->set($data['estimate']);
  $term = productivity_tracking_get_term($data['issue']['state']);
  $wrapper->field_issue_status->set($term);

  // Save milestones.
  if ($data['issue']['milestone']) {
    $term = productivity_tracking_get_term($data['issue']['milestone']['title'], 'gh_milestones');
    $wrapper->field_gh_milestone->set($term);
  }
  // Save labels.
  if ($data['issue']['labels']) {
    $term = [];
    foreach ($data['issue']['labels'] as $label) {
      $term[] = productivity_tracking_get_term($label['name'], 'gh_labels');
    }
    $wrapper->field_gh_label->set($term);
  }
}
/**
 * Get or create status term.
 */
function productivity_tracking_get_term($name, $vocab_machine_name = 'issue_status') {
  $vocab = taxonomy_vocabulary_machine_name_load($vocab_machine_name);
  $term = taxonomy_get_term_by_name($name);

  if (!$term) {
    $term = new stdClass();
    $term->name = $name;
    $term->vid = $vocab->vid;
    taxonomy_term_save($term);
  }
  else {
    $term = reset($term);
  }

  return $term;
}

/**
 * Build an associative array by day.
 *
 * @param $month
 * @param $year
 *
 * @return array|mixed
 */
function productivity_tracking_get_month_structure($month, $year, $uid) {
  // Static caching.
  $cached_data = &drupal_static(__FUNCTION__ . "$year-$month-$uid");
  if (isset($cached_data)) {
    return $cached_data;
  }

  // Global days
  $last_day_this_month  = date('t', strtotime('1.' . $month . '.' . $year));
  $assoc_globals = productivity_timewatch_get_fundays($year, $month);

  $account = user_load($uid);
  // Build skeleton of array, one item per day.
  $new_data = array();
  $new_data['days']  = [];

  // Stub for table first column.
  $first_of_the_month =  strtotime(1 . '.' . $month . '.' . $year);
  $new_data['days']['#'][]  = [
    'length' => $account->name,
    'title' => $account->name,
    'type' => 'user',
    'pr_href' => url('user', [
      'query' => [
        'uid' => $uid,
        'day' => date('d', $first_of_the_month),
        'month' => date('m', $first_of_the_month),
        'year' => date('Y', $first_of_the_month)
      ]
    ]),
    'type' => 'name',
    'mlid' => '0',
  ];
  $new_data['sum']  = array(
    'days' => array(),
  );

  // Get weekends and holidays for given user.
  $country = 'IL';
  // Weekend Friday Saturday.
  $weekend_days = array(5, 6);

  if (isset($account->field_country['und'][0]['value'])) {
    $country = $account->field_country['und'][0]['value'];
    if ($country != 'IL') {
      // Weekend Saturday Sunday.
      $weekend_days = array(6, 0);
    }
  }

  // Weekend days overriden in user profile.
  if (isset($account->field_weekend_days['und'][0]['value'])) {
    if ($account->field_weekend_days['und'][0]['value'] == 'ss') {
      $weekend_days = array(6, 0);
    }
    else {
      $weekend_days = array(5, 6);
    }
  }

  $holidays = productivity_holiday_per_month($month, $year, $country);

  // Go over days of the month and add WE and stubs.
  for ($i = 1; $i <= $last_day_this_month; $i++) {
    // Add leading zeros.
    $key = str_pad($i, 2, '0', STR_PAD_LEFT);
    $new_data['days'][$key]  = array();

    $timestamp = strtotime($key . '.' . $month . '.' . $year);
    $default_url = url('user', [
      'query' => [
        'uid' => $uid,
        'day' => date('d', $timestamp),
        'month' => date('m', $timestamp),
        'year' => date('Y', $timestamp)
      ]
    ]);

    // Holidays
    if (isset($holidays[$key])) {
      $day_item = array(
        'id' => 'new',
        'type' => 'global',
        'class' => 'holiday',
        'day' => $key,
        'length' => 'H',
        'projectName' => $holidays[$key]['title'],
        'employee' => $uid,
        'tracking' => FALSE,
        'href' => $default_url,
        'title' => $holidays[$key]['title'],
        'expandable' => FALSE,
      );
      // Add item for weekend.
      $new_data['days'][$key][] = $day_item;
    }
    else {
      $week_day = date("w", strtotime($i . '.' . $month . '.' . $year));

      // If Weekend.
      if (in_array($week_day, $weekend_days)) {
        $day_item = array(
          'id' => 'new',
          'type' => 'global',
          'class' => 'weekend',
          'day' => $key,
          'length' => 'W',
          'projectName' => 'Weekend',
          'employee' => $uid,
          'tracking' => FALSE,
          'href' => $default_url,
          'title' => 'Weekend',
          'expandable' => FALSE,
        );
        // Add item for weekend.
        $new_data['days'][$key][] = $day_item;
      }
    }
    // Add global day to user skeleton.
    if (isset($assoc_globals[$key])) {
      $assoc_globals[$key]['employee'] = $uid;
      $new_data['days'][$key][] = $assoc_globals[$key];
    }
  }

  // Get tracking data.
  $tracking = productivity_tracking_get_tracking_by_user($uid, $year, $month);

  // Prepare table for tracking data.
  while($track_record = $tracking->fetchAssoc()) {
    // Pr data.
    $pr_time = $track_record['field_track_log_field_time_spent_value'];
    $pr_gh_id = $track_record['field_track_log_field_issue_id_value'];
    $pr_title = $track_record['field_track_log_field_issue_label_value'];
    $pr_work_type = $track_record['field_track_log_field_issue_type_value'];
    $pr_developer = $track_record['field_track_log_field_github_username_value'];
    $pr_developer_uid = $track_record['field_track_log_field_employee_target_id'];

    $pr_date = $track_record['field_track_log_field_date_value'];
    $pr_date_end = $track_record['field_track_log_field_date_value2'];

    $track_id = $track_record['field_track_log_id'];
    $pr_status = $track_record['pr_status_name'];

    // Issue data.
    $repo_id = $track_record['field_github_project_id_value'];
    $estimate = $track_record['field_time_estimate_value'];
    $issue_id = $track_record['field_issue_id_value'];
    $issue_status = $track_record['name'];
    $nid = $track_record['nid'];
    $node_link = l('#', 'node/' . $nid . '/edit', array('attributes' => array('target' => '_blank')));
    $issue_title = $track_record['body_value'];
    $project_nid = $track_record['field_project_target_id'];

    $pr_url = "https://github.com/{$repo_id}/issues/$pr_gh_id";
    $issue_url = "https://github.com/{$repo_id}/issues/$issue_id";


    $day['projectName'] = $repo_id;
    $day['length'] = $pr_time;
    $day['day'] = date('d', strtotime($pr_date));
    $day['pr_href'] = $pr_url;
    $day['issue_href'] = $issue_url;
    // Work type.
    $day['type'] = $pr_work_type;
    $day['class'] = 'tracking';
    $day['title'] = $pr_title;
    $day['tracking'] = TRUE;
    $day['repo'] = $repo_id;
    $day['pr'] = $pr_gh_id;
    $day['issue'] = $issue_id;
    $day['mlid'] = $track_id;
    $day['project_nid'] = $project_nid;
    // Don't allow to edit the fields outside of the PR.
    $day['disabled'] = 'disabled';
    $day['nodelink'] = $node_link;
    $day['expandable'] = TRUE;

    $time_diff_h_dec = number_format((strtotime($pr_date_end) - strtotime($pr_date)) / 3600, 1);

    if ($time_diff_h_dec) {
      $day['time-tip'] = t('Estimated time spent is @h Hours', array(
        '@h' => $time_diff_h_dec,
      ));
    }

    $key = $day['day'];
    $new_data['days'][$key][] = $day;

    // Sums per day.
    if (empty($new_data['sum']['days'][$key])) {
      $new_data['sum']['days'][$key] = (double) $day['length'];
    }
    else {
      $new_data['sum']['days'][$key] += $day['length'];
    }

  }

  // Fill in vacation other personal global days.
  $non_regular = productivity_timewatch_get_user_sessions($uid, $year, $month, TRUE);
  $day = [];
  $day['expandable'] = FALSE;
  foreach ($non_regular as $special_day) {
    $wrapper = entity_metadata_wrapper('node', $special_day);

    $day['projectName'] = '';
    $day['length'] = strtoupper(substr($wrapper->field_session_type->label(), 0, 1));
    $day['day'] = date('d', $wrapper->field_session_date->value->value());
    $day['pr_href'] = url('node/' . $wrapper->getIdentifier() . '/edit');
    $day['type'] = 'global';
    $day['tracking'] = FALSE;
    $day['expandable'] = FALSE;
    $day['class'] = $wrapper->field_session_type->label();
    $day['mlid'] = 0;

    // Hover title.
    $from = date('H:i', $wrapper->field_session_date->value->value());
    $to = date('H:i', $wrapper->field_session_date->value2->value());
    $title = $wrapper->field_special_day_name->value() ? $wrapper->field_special_day_name->value() : $wrapper->field_session_type->label();
    $day['title'] = "$title - $from -> $to";

    $key = $day['day'];
    $new_data['days'][$key][] = $day;
  }

  // Fill empty days with create new stub template, and sum employee data.
  foreach ($new_data['days'] as $key => &$row) {
    if ($key == '#') {
      continue;
    }
    if (empty($row)) {
      $timestamp = strtotime($key . '.' . $month . '.' . $year);
      $default_url = url('user', [
        'query' => [
          'uid' => $uid,
          'day' => date('d', $timestamp),
          'month' => date('m', $timestamp),
          'year' => date('Y', $timestamp)
        ]
      ]);

      $row[] = array(
        // Set id to new to get the proper link on angular.
        'id' => 'new',
        'class' => 'empty',
        'type' => 'global',
        'day' => (string) $key,
        'length' => 'E',
        'projectName' => 'Log work',
        'employee' => $uid,
        'tracking' => FALSE,
        'href' => $default_url,
        'title' => 'Empty',
        'expandable' => TRUE,
      );
    }
  }

  // Return single user.
  $cached_data = $new_data;
  return $new_data;
}

/**
 * Build project month total.
 *
 * @param $month
 * @param $year
 *
 * @return array|mixed
 */
function productivity_tracking_get_tracking_totals($month, $year, $uid, $project_nid = FALSE) {
  // Static caching.
  $cached_data = &drupal_static(__FUNCTION__ . "$year-$month-$uid-$project_nid");
  if (isset($cached_data)) {
    return $cached_data;
  }

  // Build skeleton of array, one item per day.
  $new_data = array();

  $new_data['sum'] = array(
    'month' => 0,
    'projects' => array(),
  );

  // Get tracking data.
  $tracking = productivity_tracking_get_tracking_by_user($uid, $year, $month, $project_nid);

  // Prepare table for tracking data.
  while ($track_record = $tracking->fetchAssoc()) {
    // Pr data.
    $pr_time = $track_record['field_track_log_field_time_spent_value'];
    // Issue data.
    $project_nid = $track_record['field_project_target_id'];
    $project_key = $track_record['node_project_title'] . '-' . $project_nid;
    // Sums per project.
    if (empty($new_data['sum']['projects'][$project_key])) {
      $new_data['sum']['projects'][$project_key] = array(
        'sum' => $pr_time,
        'name' => $track_record['node_project_title'],
        'nid' => $project_nid,
      );
    }
    else {
      $new_data['sum']['projects'][$project_key]['sum'] += $pr_time;
    }

    // Sums per month.
    $new_data['sum']['month'] += $pr_time;
  }
  ksort($new_data['sum']['projects']);
  // Return single user.
  $cached_data = $new_data;
  return $new_data;
}
