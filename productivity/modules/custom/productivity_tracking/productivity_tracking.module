<?php
/**
 * @file
 * Code for the Productivity tracking feature.
 */

include_once 'productivity_tracking.features.inc';


/**
 * Implements hook_menu().
 */
function productivity_tracking_menu() {
  $items['payload'] = array(
    'page callback' => 'productivity_tracking_payload',
    'access callback' => TRUE,
  );

  $items['node/%node/issues-tracking'] = array(
    'title' => t('Tracking Report'),
    'page callback' => 'productivity_tracking_burn_report_callback',
    'page arguments' => array(1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file path' => drupal_get_path('module', 'productivity_tracking'),
    'file' => 'reports/productivity_tracking.burn.report.inc',
  );


  $items['tracking/save-tracking'] = array(
    'title' => t('Tracking Report Save Service'),
    'page callback' => 'productivity_tracking_save_callback',
    'access arguments' => array('create tracking content'),
  );

  $items['monthly-report'] = array(
    'title' => 'Issue tracking table new',
    'access arguments' => array('access content'),
    'page callback' => 'productivity_time_tracking_issue_table_callback',
    'type' => MENU_CALLBACK,
    'file' => 'monthly_report/productivity_time_tracking.table.inc'
  );

  $items['monthly-report/%node/%/%/%'] = array(
    'title' => 'Issue tracking table new',
    'access arguments' => array('access content'),
    'page callback' => 'productivity_time_tracking_issue_table_callback',
    'page arguments' => array(1, 2, 3, 4),
    'type' => MENU_CALLBACK,
    'file' => 'monthly_report/productivity_time_tracking.table.inc'
  );

  return $items;
}

/**
 * Get default query strings.
 */
function productivity_tracking_get_query_strings($args) {
  // Get query strings.
  $month = isset($_GET['month']) ? $_GET['month'] : date('m', time());
  $year = isset($_GET['year']) ? $_GET['year'] : date('Y', time());

  $day = isset($_GET['day']) ? $_GET['day'] : date('d', time());
  $date = "$day.$month.$year";

  // Before 14:00, display previous day as default.
  if (!isset($_GET['day']) && date('H') < '14') {
    $day = date('d', strtotime($date . "-1 days"));
    $month = date('m', strtotime($date . "-1 days"));
    $year = date('Y', strtotime($date . "-1 days"));
    $date = "$day.$month.$year";
  }

  $uid = isset($_GET['uid']) ? $_GET['uid'] : (isset($args[0]) ? $args[0] : 1);

  return [
  'day' => $day,
  'month' => $month,
  'year' => $year,
  'uid' => $uid,
  'date' => $date,
  ];
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function productivity_tracking_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Implements hook_theme().
 */
function productivity_tracking_theme($existing, $type, $theme, $path) {
  return array(
    'tracking_burn_table' => array(
      'variables' => array(),
      'template' => 'productivity_tracking_burn_table',
      'path' => $path . '/reports',
    ),
  );
}

/**
 *  Update tracking multifiled.
 */
function productivity_tracking_update($track) {
  // Save in regular data.
  $res = db_update('field_data_field_track_log')
    ->fields(array(
        'field_track_log_field_issue_id_value' => $track['pr'] ? $track['pr'] : NULL,
        'field_track_log_field_issue_label_value' => $track['description'],
        'field_track_log_field_issue_type_value' => $track['type'],
        'field_track_log_field_time_spent_value' => $track['time_spent'] ? $track['time_spent'] : 0,
      )
    )
    ->condition('field_track_log_id', $track['mlid'])
    ->execute();

  // Save in revision.
  $res_rev = db_update('field_revision_field_track_log')
    ->fields(array(
        'field_track_log_field_issue_id_value' => $track['pr'] ? $track['pr'] : NULL,
        'field_track_log_field_issue_label_value' => $track['description'],
        'field_track_log_field_issue_type_value' => $track['type'],
        'field_track_log_field_time_spent_value' => $track['time_spent'] ? $track['time_spent'] : 0,
      )
    )
    ->condition('field_track_log_id', $track['mlid'])
    ->execute();

  return $res && $res_rev;
}

/**
 *  Delete tracking multifiled.
 */
function productivity_tracking_delete($mlid) {
  $res = db_delete('field_data_field_track_log')
    ->condition('field_track_log_id', $mlid)
    ->execute();

  $res_rev = db_delete('field_revision_field_track_log')
    ->condition('field_track_log_id', $mlid)
    ->execute();

  return $res && $res_rev;
}

/**
 * Save tracking from tacking table.
 */

function productivity_tracking_save_callback() {
  $results = [];
  $json = file_get_contents('php://input');
  $tracking = json_decode($json, TRUE);
  foreach ($tracking['tracking'] as $track) {
    // Existing Tracking, just update.
    $ids = explode('|', $track['mlid']);
    $attr = $ids[1];
    $delete = $ids[2];
    $track['mlid'] = $ids[0];


    // Delete.
    if ($delete) {
      // Make sure delete is not on a new item that was never saved.
      if ($track['mlid'] != 'new') {
        $results[] = array(
          'mlid' => $track['mlid'],
          'new' => 0,
          'delete' => $delete,
          'attr' => $attr,
          'result' => productivity_tracking_delete($track['mlid']),
        );
      }
    }
    // Update.
    elseif ($track['mlid'] != 'new') {
      // Update info that might change.
      $results[] = array(
        'mlid' => $track['mlid'],
        'new' => 0,
        'delete' => $delete,
        'attr' => $attr,
        'result' => productivity_tracking_update($track),
      );
    }
    // New tracking.
    else {
      $uid = $tracking['data']['uid'];
      $data_issue = [
        'project' => $track['project_nid'],
        'repo' => $track['repo'],
        'issue_id' => $track['issue'] ? $track['issue'] : 0,
        'title' => $track['description'],
        'type' => $track['type'],
        'time' => $track['time_spent'],
        'uid' => $uid,
        // Case the issue does not exist set defaults.
        'estimate' => 0,
        'status' => 'open',
      ];

      // Get or create tracking node.
      $wrapper = productivity_tracking_get_tracking_node($data_issue);
      // Save PR.
      $node = $wrapper->value();
      $logs = array();
      $account_wrapper = entity_metadata_wrapper('user', $uid);

      $data = [
        'date_start' => date("Y-m-d H:i:s", strtotime($tracking['data']['date_str'])),
        'date_end' => date("Y-m-d H:i:s", strtotime($tracking['data']['date_str'])),
        'label' => $track['description'],
        'issue_id' => $track['pr'] ? $track['pr'] : 0,
        'status' => 'open',
        'github_username' => $account_wrapper->field_github_username->value(),
        'time_spent' => $track['time_spent'],
        'issue_type' => $track['type'],
        'uid' => $uid,
      ];

      // Create a new tracking data.
      $logs['und'][] = productivity_tracking_create_multifields_track($data, $wrapper);

      // Rebuild structure with previous logs.
      $index = 0;
      if (isset($node->field_track_log['und'])) {
        foreach ($node->field_track_log['und'] as $existing_log) {
          $logs['und'][] = $existing_log;
          $index++;
        }
      }
      $node->field_track_log = $logs;
      // Save node.
      $wrapper->save();
      $results[] = array(
        'mlid' => $node->field_track_log['und'][$index]['id'],
        'result' => 1,
        'delete' => $delete,
        'attr' => $attr,
        'new' => 1,
      );
    }
  }
  global $user;
  ctools_include('content');
  $nav = ctools_content_render('tracking_nav', 'tracking_nav', [], [], [$user->uid], [], '');
  $nav = $nav->content;
  drupal_json_output(array(
    'saved' => $results,
    'nav' => $nav,
    )
  );
  drupal_exit();
}
/**
 * Github endpoint callback
 */
function productivity_tracking_payload() {
  // set NULL to disable check
  $hookSecret = variable_get('productivity_github_secret', '1234');

  $rawPost = NULL;
  // Check security secret.
  if ($hookSecret !== NULL) {
    if (!isset($_SERVER['HTTP_X_HUB_SIGNATURE'])) {
      throw new \Exception("HTTP header 'X-Hub-Signature' is missing.");
    }
    elseif (!extension_loaded('hash')) {
      throw new \Exception("Missing 'hash' extension to check the secret code validity.");
    }

    // Separate algo and hash.
    list($algo, $hash) = explode('=', $_SERVER['HTTP_X_HUB_SIGNATURE'], 2) + array('', '');
    if (!in_array($algo, hash_algos(), TRUE)) {
      throw new \Exception("Hash algorithm '$algo' is not supported.");
    }

    // Check hash.
    $rawPost = file_get_contents('php://input');
    if ($hash !== hash_hmac($algo, $rawPost, $hookSecret)) {
      throw new \Exception('Hook secret does not match.');
    }
  };

  // Check event header.
  if (!isset($_SERVER['CONTENT_TYPE'])) {
    throw new \Exception("Missing HTTP 'Content-Type' header.");
  }
  elseif (!isset($_SERVER['HTTP_X_GITHUB_EVENT'])) {
    throw new \Exception("Missing HTTP 'X-Github-Event' header.");
  }


  switch ($_SERVER['CONTENT_TYPE']) {
    case 'application/json':
      $json = $rawPost ?: file_get_contents('php://input');
      break;
    case 'application/x-www-form-urlencoded':
      $json = $_POST['payload'];
      break;
    default:
      throw new \Exception("Unsupported content type: $_SERVER[HTTP_CONTENT_TYPE]");
  }

  # Payload structure depends on triggered event
  # https://developer.github.com/v3/activity/events/types/
  $payload = json_decode($json, TRUE);

  switch ($event = strtolower($_SERVER['HTTP_X_GITHUB_EVENT'])) {
    // Issue event https://developer.github.com/v3/activity/events/types/#issuesevent
    // https://developer.github.com/v3/activity/events/types/#pullrequestevent.
    case 'issues' || 'pull_request':
      productivity_tracking_gh_payload($payload, $event);
      break;
    default:
      header('HTTP/1.0 404 Not Found');
      echo "Event:{$_SERVER['HTTP_X_GITHUB_EVENT']} Payload:\n";
      watchdog('productivity_tracking', t('@event is not supported', array('@event' => $_SERVER['HTTP_X_GITHUB_EVENT'])));
      die();
  }
}

/**
 * Handle PR event.
 */
function productivity_tracking_gh_payload($payload, $event) {

  // Get related issue from PR body.
  if ($event == 'pull_request') {
    $pr = $payload['pull_request'];
    // Look in body for issue.
    $issues = productivity_tracking_parse_related_issue($payload['pull_request']['body'], $payload['repository']['name'], $payload['repository']['owner']['login']);
    // Look in title for issue.
    $issues += productivity_tracking_parse_related_issue($payload['pull_request']['title'], $payload['repository']['name'], $payload['repository']['owner']['login'], TRUE);

  }
  // Issue event.
  else {
    // Take issue info straight from payload.
    $pr = FALSE;
    $issues[] = [
      'issue' => $payload['issue'],
      'estimate' => productivity_tracking_parse_time_estimate($payload['issue']['title']),
      'related_issues' => [],
    ];
  }

  // No issue connected.
  if (empty($issues)) {
    // If PR is orphan and Pr has an estimate in title, then create a tracking.
    if ($estimate = productivity_tracking_parse_time_estimate($payload['pull_request']['title'])) {
      $issues[] = [
        'issue' => $payload['pull_request'],
        'estimate' => $estimate,
        'related_issues' => [],
      ];
    }
    else {
      // TODO: Send message to account manager about no issue and no estimate.
      // TODO: Probably better to have this in single daily email.
      $issues[] = [
        'issue' => $payload['pull_request'],
        'estimate' => 0,
        'related_issues' => [],
      ];
    }
  }

  // Go ovre all related issue and get related tracking node.
  foreach ($issues as $issue) {
    $uid = productivity_tracking_get_uid_by_github_username(check_plain($payload['sender']['login']));
    $project_nid = productivity_tracking_get_project_by_repository($payload['repository']);

    // Bypass if project or user are not in the system.
    if (!$project_nid || !$uid) {
      continue;
    }

    $data_issue = [
      'issue_id' => $issue['issue']['number'],
      'repo' => $payload['repository']['full_name'],
      'title' => $issue['issue']['title'],
      'project' => $project_nid,
      'estimate' => $issue['estimate'],
      'status' => $issue['issue']['state'],
      'uid' => $uid,
    ];


    $wrapper = productivity_tracking_get_tracking_node($data_issue, TRUE);

    // Only create tracking stub if a new PR was pushed.
    // This will be later used to prepopulate the tracking for developers.
    if ($pr) {
      $node = $wrapper->value();
      $logs = array();

      // We should create one stub log per day per user per issue number.
      // issue_id.
      $found_key = -1;
      if (isset($node->field_track_log['und'])) {
        foreach ($node->field_track_log['und'] as $key => $existing_log) {
          // Convert date.
          $existing_pr_day = date('Ymd', strtotime($existing_log['field_date']['und'][0]['value']));
          $pr_payload_date = date('Ymd', strtotime($payload['pull_request']['updated_at']));

          // Check if we have a match for same PR, same day, Same user.
          if ($existing_log['field_github_username']['und'][0]['value'] == $payload['sender']['login']
            && $existing_log['field_issue_id']['und'][0]['value'] == $pr['number']
            && $existing_pr_day == $pr_payload_date) {
            $found_key = $key;
            break;
          }
        }
      }
      // Update existing log, with new info.
      if ($found_key != -1) {
        // Update info that might change.
        $node->field_track_log['und'][$found_key]['field_issue_label']['und'][0]['value'] = $pr['title'];
        $node->field_track_log['und'][$found_key]['field_date']['und'][0]['value2'] = date("Y-m-d H:i:s",strtotime($pr['updated_at']));

        $term = productivity_tracking_get_term_status($pr['state']);
        $node->field_track_log['und'][$found_key]['field_issue_status']['und'][0]['target_id'] = $term->tid;
      }
      else {
        $data = [
          'date_start' => date("Y-m-d H:i:s",strtotime($pr['updated_at'])),
          'date_end' => date("Y-m-d H:i:s",strtotime($pr['updated_at'])),
          'label' => $pr['title'],
          'issue_id' => $pr['number'],
          'status' => $pr['state'],
          'github_username' => $payload['sender']['login'],
          'time_spent' => 0,
          'issue_type' => '',
          'uid' => $uid,
        ];
        // Create a new tracking data.
        $logs['und'][] = productivity_tracking_create_multifields_track($data, $wrapper);

        // Rebuild structure with previous logs.
        if (isset($node->field_track_log['und'])) {
          foreach ($node->field_track_log['und'] as $existing_log) {
            $logs['und'][] = $existing_log;
          }
        }
        $node->field_track_log = $logs;
      }
    }

    // Save node.
    $wrapper->save();
  }

}

/**
 *
 * Get the project ID from the repository name.
 *
 * @param $repository_info
 *  A github repository names.
 *
 * @return int
 *   Project node ID.
 */
function productivity_tracking_get_project_by_repository($repository_info) {
  // We need to add a second query since value2 of date has a default of value(1).
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->fieldCondition('field_github_repository_name', 'value', $repository_info['full_name'])
    // Just look for active or not started projects.
    ->fieldCondition('field_status', 'value', 'done', '!=')
    ->propertyOrderBy('created', 'DESC')
    ->range(0, 1)
    ->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');

  $result = $query->execute();
  if (isset($result['node'])) {
    $nid = reset($result['node']);
    return $nid;
  }

  // Print error if no repo was found.
  watchdog('productivity', t('No project with github repository: @repository', array('@repository' => print_r($repository_info, TRUE))));
  return FALSE;
}

/**
 * Get user ID from the GitHub username.
 *
 * @param string $github_username
 *   A github username.
 *
 * @return int
 *   Account ID.
 */
function productivity_tracking_get_uid_by_github_username($github_username) {
  if ($uid = productivity_tracking_get_entity_id_by_field_value('field_github_username', 'user', $github_username)) {
    return $uid;
  }

  watchdog('productivity', t('No user with github username: @username', array('@username' => $github_username)));
}

/**
 * Fetch an entity ID by a unique field value.
 *
 * @param $field
 *   Field name.
 * @param $bundle
 *   Entity bundle.
 * @param $value
 *   Field value.
 *
 * @return int
 *   Entity ID.
 */
function productivity_tracking_get_entity_id_by_field_value($field, $bundle, $value) {
  // Using db_select to allow this query for anonymous.
  $result = db_select('field_data_' . $field, 'f')
    ->fields('f', array('entity_id'))
    ->condition('bundle', $bundle)
    ->condition($field . '_value', $value)
    ->range(0, 1)
    ->execute()
    ->fetchAssoc();

  if (!empty($result['entity_id'])) {
    return $result['entity_id'];
  }
}

/**
 * Get entity reference connections.
 *
 * @param $project_nid
 *  The project nid.
 *
 * @param $work_type
 *  qa, dev, management or other type.
 *
 * @return
 *   SelectQuery::execute();
 */
function productivity_tracking_get_tracking($project_nid = FALSE, $work_type = FALSE, $year = FALSE, $month = FALSE) {
  if ($month == 'all') {
    $project_start_month = format_string("@year-01-01", array('@year' => $year));
    $project_end_month = format_string("@year-12-31", array('@year' => $year));
  }
  //
  else {
    $project_start_month = format_string("@year-@month-01", array(
      '@year' => $year,
      '@month' => $month
    ));
    $project_end_month = format_string("@year-@month-01", array(
      '@year' => ($month == 12) ? $year + 1 : $year,
      '@month' => ($month == 12) ? 1 : ($month + 1),
    ));
  }

  // List of issues for a project nid.
  $query = db_select('node', 'n');

  $node_fields = [
    'p' => 'field_project',
    'e' => 'field_time_estimate',
    'i' => 'field_issue_id',
    'gpi' => 'field_github_project_id',
    't' => 'field_track_log',
    'st' => 'field_issue_status',
    'b' => 'body',
  ];

  foreach ($node_fields as $alias => $field) {
    $query
      ->leftjoin("field_data_$field", $alias, "n.nid = $alias.entity_id");
  }

  $query
    ->leftjoin("taxonomy_term_data", 'issue_status', 'issue_status.tid = st.field_issue_status_target_id');

  $query
    ->leftjoin("taxonomy_term_data", 'pr_status', 'pr_status.tid = t.field_track_log_field_issue_status_target_id');

  $query
    ->fields('n', array('title', 'nid', 'uid'))
    ->fields('e', array('field_time_estimate_value'))
    ->fields('i', array('field_issue_id_value'))
    ->fields('gpi', array('field_github_project_id_value'))
    ->fields('t')
    ->fields('b')
    ->fields('issue_status', array('name'))
    ->fields('pr_status', array('name'))
    ->fields('p', array('field_project_target_id'));

  if ($project_nid) {
    $query
      ->condition('p.field_project_target_id', $project_nid);
  }

  // Return all time.
  if ($year) {
    $query
      ->condition('t.field_track_log_field_date_value', $project_start_month, '>=')
      ->condition('t.field_track_log_field_date_value', $project_end_month, '<');
  }

  $query
    ->condition('type', 'tracking')
    ->condition('status', NODE_PUBLISHED)
    ->orderBy('gpi.field_github_project_id_value')
    ->orderBy('i.field_issue_id_value');

  if ($work_type) {
    $query->condition('t.field_track_log_field_issue_type_value', $work_type);
  }

  $result = $query->execute();

  return $result;
}

/**
 * Get entity reference connections.
 *
 * @param $work_type
 *  qa, dev, management or other type.
 *
 * @return
 *   SelectQuery::execute();
 */
function productivity_tracking_get_tracking_by_user($uid, $year = FALSE, $month = 'all', $work_type = FALSE) {

  if ($month == 'all') {
    $start_date = format_string("@year-01-01 00:00:00", array('@year' => $year));
    $end_date = format_string("@year-01-01 00:00:00", array('@year' => $year+1));
  }
  else {
    $start_date = format_string("@year-@month-01 00:00:00", array(
      '@year' => $year,
      '@month' => str_pad($month, 2, '0', STR_PAD_LEFT),
    ));
    $end_date = format_string("@year-@month-01 00:00:00", array(
      '@year' => ($month == 12) ? $year+1 : $year,
      '@month' => str_pad(($month == 12) ? 1 : ($month + 1), 2, '0', STR_PAD_LEFT),
    ));
  }

  // List of issues for a project nid.
  $query = db_select('node', 'n');

  $node_fields = [
    'p' => 'field_project',
    'e' => 'field_time_estimate',
    'i' => 'field_issue_id',
    'gpi' => 'field_github_project_id',
    't' => 'field_track_log',
    'st' => 'field_issue_status',
    'b' => 'body',
  ];

  foreach ($node_fields as $alias => $field) {
    $query
      ->leftjoin("field_data_$field", $alias, "n.nid = $alias.entity_id");
  }

  $query
    ->leftjoin("taxonomy_term_data", 'issue_status', 'issue_status.tid = st.field_issue_status_target_id');

  $query
    ->leftjoin("taxonomy_term_data", 'pr_status', 'pr_status.tid = t.field_track_log_field_issue_status_target_id');

  $query
    ->fields('n', array('title', 'nid', 'uid'))
    ->fields('e', array('field_time_estimate_value'))
    ->fields('i', array('field_issue_id_value'))
    ->fields('gpi', array('field_github_project_id_value'))
    ->fields('t')
    ->fields('b')
    ->fields('issue_status', array('name'))
    ->fields('pr_status', array('name'))
    ->fields('p', array('field_project_target_id'));

  $query
    ->condition('type', 'tracking')
    ->condition('status', NODE_PUBLISHED)
    ->condition('t.field_track_log_field_employee_target_id', $uid)
    ->orderBy('t.field_track_log_id')
    ->orderBy('gpi.field_github_project_id_value')
    ->orderBy('i.field_issue_id_value');

  if ($work_type) {
    $query->condition('t.field_track_log_field_issue_type_value', $work_type);
  }

  // Return all time.
  if ($year) {
    $query
      ->condition('t.field_track_log_field_date_value', $start_date, '>=')
      ->condition('t.field_track_log_field_date_value', $end_date, '<');
  }

  $result = $query->execute();

  return $result;
}

/**
 * Parse time estimation from string.
 */
function productivity_tracking_parse_time_estimate($string) {
  // Get time estimate from title, if it has any.
  $matches = array();
  $estimate = 0;
  if (preg_match('/\[([0-9]+)[h|H]\]|\[([0-9]+\.[0-9]+)[h|H]\]/', $string, $matches)) {
    // The iss has a time estimate.
    $estimate = empty($matches[1]) ? (empty($matches[2]) ? 0 : $matches[2]) : $matches[1];
  }
  return $estimate;
}

/**
 * Parse related issue numnber.
 *
 * @param $no_hash
 *   Search fo issue number without # too.
 *
 * @return array().
 *   An array with GH issue array with info from GH.
 */
function productivity_tracking_parse_related_issue($string, $repo, $user, $no_hash = FALSE) {
  if ($no_hash) {
    $re = '/(\d+)/';
  }
  else {
    $re = '/#(\d+)/';
  }
  $str = $string;
  preg_match_all($re, $str, $matches);
  $issues = [];
  foreach ($matches[1] as $issue_id_from_body) {
    $issue = productivity_tracking_get_issue_info($repo, $issue_id_from_body, $user, FALSE);
    if (!isset($issue['issue']['pull_request'])) {
      // Only adds non PRs
      $issues[$issue_id_from_body] = $issue;
    }
  }
  return $issues;
}

/**
 * Return PR or issue info with estimate from github API.
 */
function productivity_tracking_get_issue_info($repo, $issue_id, $user = 'Gizra', $with_related = TRUE) {
  // Get ifo from GH.
  $issue = productivity_tracking_get_issue($repo, $issue_id, $user);

  if (empty($issue)) {
    return [
      'issue' => [],
      'estimate' => 0,
      'related_issues' => [],
    ];
  }

  // Get time estimate from title, if it has any.
  $estimate = productivity_tracking_parse_time_estimate($issue['title']);

  $issues = [];
  // Find issue connected.
  if ($with_related) {
    $issues = productivity_tracking_parse_related_issue($issue['body'], $repo, $user);
  }

  $data = [
    'issue' => $issue,
    'estimate' => $estimate,
    'related_issues' => $issues,
  ];

  return $data;
}

/**
 * Return PR or issue info from github API.
 */
function productivity_tracking_get_issue($repo, $issue_id, $user = 'Gizra') {
  $cid = "$user/$repo/$issue_id";
  $data = &drupal_static($cid);

  if (!isset($data)) {
    if ($cache = cache_get($cid)) {
      $data = $cache->data;
    }
    else {
      $client = github_api_client();
      try {
        // Get ifo from GH.
        $data =  $client->issue()->show($user, $repo, $issue_id);
        cache_set($cid, $data);

      } catch (Exception $exception) {
        watchdog('productivity_github', 'looking for @cid : @exception', array('@cid' => $cid, '@exception' => $exception->getMessage()), WATCHDOG_ERROR);
        // CAche nit found.
        if ($exception->getCode() == 404){
          cache_set($cid, []);
        }
        return [];
      }
    }
  }
  return $data;
}

/**
 * Create a well formated log track multifileld.
 *
 * @param $data
 *  array().
 *
 *   'date' => time(),
 *   'label' => '',
 *   'last_push' => time(),
 *   'issue_id' => 0,
 *   'status' => 'closed',
 *   'github_username' => '',
 *   'time_spent' => 0,
 *   'issue_type' => 'dev',
 *   'uid' => 0,
 */
function productivity_tracking_create_multifields_track($data) {
  $data += [
    'date_start' => time(),
    'date_end' => time(),
    'label' => '',
    'last_push' => time(),
    'issue_id' => 0,
    'status' => 'closed',
    'github_username' => '',
    'time_spent' => 0,
    'issue_type' => '',
    'uid' => 0,
  ];

  $log = array();
  $log['field_date']['und'][0]['value'] = $data['date_start'];
  $log['field_date']['und'][0]['value2'] = $data['date_end'];
  $log['field_issue_label']['und'][0]['value'] =  $data['label'];
  // Last push use as last edited field.
  $log['field_last_push']['und'][0]['value'] = date("Y-m-d H:i:s");
  $log['field_issue_id']['und'][0]['value'] =  $data['issue_id'];
  $term = productivity_tracking_get_term_status( $data['status']);
  $log['field_issue_status']['und'][0]['target_id'] = $term->tid;
  $log['field_github_username']['und'][0]['value'] =  $data['github_username'];
  $log['field_time_spent']['und'][0]['value'] = $data['time_spent'];
  $log['field_issue_type']['und'][0]['value'] = $data['issue_type'];
  $log['field_employee']['und'][0]['target_id'] = $data['uid'];

  return $log;
}

/**
 * Try to find a matching tacking node, or create one.
 *
 * @param $data
 *   array();
 *
 *  'issue_id - not requires for new
 *  'repo' - not requires for new
 *  'title'- Required for new if no issue id.
 *  'project' - Required for new
 *  'estimate' -  Required for new
 *  'uid' -  Required for new
 *  'status' -  Required for new
 */
function productivity_tracking_get_tracking_node($data, $update_existing = FALSE) {

  $node = FALSE;
  if ($data['issue_id'] && $data['repo']) {
    // Look for a tracking of the same issue.
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'tracking')
      ->fieldCondition('field_issue_id', 'value', $data['issue_id'])
      ->fieldCondition('field_github_project_id', 'value', $data['repo'])
      ->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT')
      ->range(0, 1)
      ->execute();

    if (!empty($result['node'])) {
      $nid = reset($result['node']);
      $node = node_load($nid->nid);
      $wrapper = entity_metadata_wrapper('node', $node);

      // Update estimate and status.
      if ($update_existing) {
        $wrapper->field_time_estimate->set($data['estimate']);
        $term = productivity_tracking_get_term_status($data['status']);
        $wrapper->field_issue_status->set($term);
      }
    }
  }
  // Not found, create a new one.
  if (!$node) {
    // If it's a GH related tracking.
    if ($data['issue_id'] != '') {
      $title = "Tracking for issue {$data['repo']}/{$data['issue_id']}";
    }
    else {
      if (!$data['title']) {
        $project_wrapper = entity_metadata_wrapper('node', $data['project']);
        $data['title'] = $project_wrapper->label();
      }
      $title = "Tracking for project: {$data['title']}";
    }
    global $user;

    $values = array(
      'title' => $title,
      'type' => 'tracking',
       // If author is anonymous (pushed form GH) use employee as default.
      'uid' => $user->uid ? $data['uid'] : $user->uid,
      'status' => 1,
    );
    $node = entity_create('node', $values);

    $wrapper = entity_metadata_wrapper('node', $node);
    $wrapper->field_project->set($data['project']);
    $wrapper->field_issue_id->set($data['issue_id']);
    $wrapper->field_github_project_id->set($data['repo']);
    $wrapper->body->value->set($data['title']);

    $wrapper->field_time_estimate->set($data['estimate']);
    $term = productivity_tracking_get_term_status($data['status']);
    $wrapper->field_issue_status->set($term);
  }

  return $wrapper;
}

/**
 * Get or create status term.
 */
function productivity_tracking_get_term_status($name) {
  $vocab = taxonomy_vocabulary_machine_name_load('issue_status');
  $term = taxonomy_get_term_by_name($name);

  if (!$term) {
    $term = new stdClass();
    $term->name = $name;
    $term->vid = $vocab->vid;
    taxonomy_term_save($term);
  }
  else {
    $term = reset($term);
  }

  return $term;
}

/**
 * Build an associative array by day.
 *
 * @param $month
 * @param $year
 *
 * @return array|mixed
 */
function productivity_tracking_get_month_structure($month, $year, $uid) {
  // Static caching.
  $cached_data = &drupal_static(__FUNCTION__ . "$year-$month-$uid");
  if (isset($cached_data)) {
    return $cached_data;
  }

  // Global days
  $last_day_this_month  = date('t', strtotime('1.' . $month . '.' . $year));
  $assoc_globals = productivity_timewatch_get_global_days($year, $month);

  $account = user_load($uid);
  // Build skeleton of array, one item per day.
  $new_data = array();
  $new_data['days']  = [];
  // Stub for table first column.

  $first_of_the_month =  strtotime(1 . '.' . $month . '.' . $year);
  $new_data['days']['#'][]  = [
      'length' => $account->name,
      'title' => $account->name,
      'type' => 'user',
      'pr_href' => url('user', [
        'query' => [
          'uid' => $uid,
          'day' => date('d', $first_of_the_month),
          'month' => date('m', $first_of_the_month),
          'year' => date('Y', $first_of_the_month)
        ]
      ]),
      'type' => 'name',
      'mlid' => '0',
    ];
  $new_data['sum']  = array(
    'month' => 0,
    'projects' => array(),
    'days' => array(),
  );

  // Get weekends and holidays for given user.
  $country = 'IL';
  // Weekend Friday Saturday.
  $weekend_days = array(5, 6);

  if (isset($account->field_country['und'][0]['value'])) {
    $country = $account->field_country['und'][0]['value'];
    if ($country != 'IL') {
      // Weekend Saturday Sunday.
      $weekend_days = array(6, 0);
    }
  }
  $holidays = productivity_holiday_per_month($month, $year, $country);

  // Go over days of the month and add WE and stuns.
  for ($i = 1; $i <= $last_day_this_month; $i++) {
    // Add leading zeros.
    $key = str_pad($i, 2, '0', STR_PAD_LEFT);
    $new_data['days'][$key]  = array();

    $timestamp = strtotime($key . '.' . $month . '.' . $year);
    $default_url = url('user', [
      'query' => [
        'uid' => $uid,
        'day' => date('d', $timestamp),
        'month' => date('m', $timestamp),
        'year' => date('Y', $timestamp)
      ]
    ]);

    // Holidays
    if (isset($holidays[$key])) {
      $day_item = array(
        'id' => 'new',
        'type' => 'global',
        'class' => 'holiday',
        'day' => $key,
        'length' => 'H',
        'projectName' => $holidays[$key]['label'],
        'employee' => $uid,
        'tracking' => FALSE,
        'href' => $default_url,
        'title' => $holidays[$key]['label'],
        'expandable' => FALSE,
      );
      // Add item for weekend.
      $new_data['days'][$key][] = $day_item;
    }
    else {
      $week_day = date("w", strtotime($i . '.' . $month . '.' . $year));

      // If Weekend.
      if (in_array($week_day, $weekend_days)) {
        $day_item = array(
          'id' => 'new',
          'type' => 'global',
          'class' => 'weekend',
          'day' => $key,
          'length' => 'W',
          'projectName' => 'Weekend',
          'employee' => $uid,
          'tracking' => FALSE,
          'href' => $default_url,
          'title' => 'Weekend',
          'expandable' => FALSE,
        );
        // Add item for weekend.
        $new_data['days'][$key][] = $day_item;
      }
    }
    // Add global day to user skeleton.
    if (isset($assoc_globals[$key])) {
      $assoc_globals[$key]['employee'] = $uid;
      $new_data['days'][$key][] = $assoc_globals[$key];
    }
  }

  // Get tracking data.
  $tracking = productivity_tracking_get_tracking_by_user($uid, $year, $month);

  // Prepare table for tracking data.
  while($track_record = $tracking->fetchAssoc()) {
    // Pr data.
    $pr_time = $track_record['field_track_log_field_time_spent_value'];
    $pr_gh_id = $track_record['field_track_log_field_issue_id_value'];
    $pr_title = $track_record['field_track_log_field_issue_label_value'];
    $pr_work_type = $track_record['field_track_log_field_issue_type_value'];
    $pr_developer = $track_record['field_track_log_field_github_username_value'];
    $pr_developer_uid = $track_record['field_track_log_field_employee_target_id'];

    $pr_date = $track_record['field_track_log_field_date_value'];
    $pr_date_end = $track_record['field_track_log_field_date_value2'];

    $track_id = $track_record['field_track_log_id'];
    $pr_status = $track_record['pr_status_name'];

    // Issue data.
    $repo_id = $track_record['field_github_project_id_value'];
    $estimate = $track_record['field_time_estimate_value'];
    $issue_id = $track_record['field_issue_id_value'];
    $issue_status = $track_record['name'];
    $nid = $track_record['nid'];
    $node_link = l('#', 'node/' . $nid . '/edit', array('attributes' => array('target' => '_blank')));
    $issue_title = $track_record['body_value'];
    $project_nid = $track_record['field_project_target_id'];

    $pr_url = "https://github.com/{$repo_id}/issues/$pr_gh_id";
    $issue_url = "https://github.com/{$repo_id}/issues/$issue_id";


    $day['projectName'] = $repo_id;
    $day['length'] = $pr_time;
    $day['day'] = date('d', strtotime($pr_date));
    $day['pr_href'] = $pr_url;
    $day['issue_href'] = $issue_url;
    $day['type'] = 'tracking';
    $day['class'] = $pr_work_type;
    $day['title'] = $pr_title;
    $day['tracking'] = TRUE;
    $day['repo'] = $repo_id;
    $day['pr'] = $pr_gh_id;
    $day['issue'] = $issue_id;
    $day['mlid'] = $track_id;
    $day['project_nid'] = $project_nid;
    // Don't allow to edit the fields outside of the PR.
    $day['disabled'] = 'disabled';
    $day['nodelink'] = $node_link;
    $day['expandable'] = TRUE;

    $time_diff_h_dec = number_format((strtotime($pr_date_end) - strtotime($pr_date)) / 3600, 1);

    if ($time_diff_h_dec) {
      $day['time-tip'] = t('Estimated time spent is @h Hours', array(
        '@h' => $time_diff_h_dec,
      ));
    }


    $key = $day['day'];
    $new_data['days'][$key][] = $day;

    // Sums per project.
    if (empty($new_data['sum']['projects'][$project_nid])) {
      $node = node_load($project_nid);
      $new_data['sum']['projects'][$project_nid] = array(
         'sum' => $day['length'],
         'name' => $node->title,
      );
    }
    else {
      $new_data['sum']['projects'][$project_nid]['sum'] += $day['length'];
    }

    // Sums per day.
    if (empty($new_data['sum']['days'][$key])) {
      $new_data['sum']['days'][$key] = $day['length'];
    }
    else {
      $new_data['sum']['days'][$key] += $day['length'];
    }

    // Sums per month.
    $new_data['sum']['month'] += $day['length'];
  }

  // Fill in vacation other personal global days.
  $non_regular = productivity_timewatch_get_user_sessions($uid, $year, $month, TRUE);
  $day = [];
  $day['expandable'] = FALSE;
  foreach ($non_regular as $special_day) {
    $wrapper = entity_metadata_wrapper('node', $special_day);

    $day['projectName'] = '';
    $day['length'] = strtoupper(substr($wrapper->field_session_type->label(), 0, 1));
    $day['day'] = date('d', $wrapper->field_session_date->value->value());
    $day['pr_href'] = url('node/' . $wrapper->getIdentifier() . '/edit');
    $day['type'] = 'tracking';
    $day['expandable'] = FALSE;
    $day['class'] = $wrapper->field_session_type->label();
    $day['mlid'] = 0;

    // Hover title.
    $from = date('H:m', $wrapper->field_session_date->value->value());
    $to = date('H:m', $wrapper->field_session_date->value2->value());
    $title = $wrapper->field_special_day_name->value() ? $wrapper->field_special_day_name->value() : $wrapper->field_session_type->label();
    $day['title'] = "$title - $from -> $to";

    $key = $day['day'];
    $new_data['days'][$key][] = $day;
  }

  // Fill empty days with create new stub template, and sum employee data.
  foreach ($new_data['days'] as $key => &$row) {
    if ($key == '#') {
      continue;
    }
    if (empty($row)) {
      $timestamp = strtotime($key . '.' . $month . '.' . $year);
      $default_url = url('user', [
        'query' => [
          'uid' => $uid,
          'day' => date('d', $timestamp),
          'month' => date('m', $timestamp),
          'year' => date('Y', $timestamp)
        ]
      ]);

      $row[] = array(
        // Set id to new to get the proper link on angular.
        'id' => 'new',
        'class' => 'empty',
        'type' => 'global',
        'day' => (string) $key,
        'length' => 'E',
        'projectName' => 'Log work',
        'employee' => $uid,
        'tracking' => FALSE,
        'href' => $default_url,
        'title' => 'Empty',
        'expandable' => TRUE,
      );
    }
  }

  // Return single user.
  $cached_data = $new_data;
  return $new_data;
}
